
//******************************************************************************
// Definitions
//******************************************************************************

        //Set this to 0 to disable all debugging messages
#define ENABLE_DEBUG_PRINTS                  1

        // Number of connections
#define NUM_OF_CONNS                         8

        // size of i[]
#define NUM_OF_I_PARAMS                     (8)

//BLE EVENT MSG IDs
#define BLE_EVBLEMSGID_CONNECT                          0 // msgCtx = connection handle
#define BLE_EVBLEMSGID_DISCONNECT                       1 // msgCtx = connection handle
#define BLE_EVBLEMSGID_IMMEDIATE_ALERT_SERVICE_ALERT    2 // msgCtx = alert level
#define BLE_EVBLEMSGID_LINKLOSS_SERVICE_ALERT           3 // msgCtx = alert level
#define BLE_EVBLEMSGID_SERVICE_ERROR                    4 // msgCtx = resultcode
#define BLE_EVBLEMSGID_HTS_INDICATION_STATE             5 // msgCtx = new indication state 0=off, 1=on
#define BLE_EVBLEMSGID_HTS_INDICATION_CNF               6 // msgCtx = not used
#define BLE_EVBLEMSGID_BPS_INDICATION_STATE             7 // msgCtx = new indication state 0=off, 1=on
#define BLE_EVBLEMSGID_BPS_INDICATION_CNF               8 // msgCtx = not used
#define BLE_EVBLEMSGID_DISPLAY_PASSKEY                  9 // msgCtx = passcode to display
#define BLE_EVBLEMSGID_NEW_BOND                        10 // msgCtx = connection handle
#define BLE_EVBLEMSGID_AUTH_KEY_REQUEST                11 // msgCtx = 1 for passkey, 2 for 16 byte OOB data
#define BLE_EVBLEMSGID_HRS_NOTIFICATION_STATE          12 // msgCtx = new notification state 0=off, 1=on
//#define FUTURE_USE                                   13
#define BLE_EVBLEMSGID_CONN_PARMS_UPDATE               14 // msgCtx = connection handle
#define BLE_EVBLEMSGID_CONN_PARMS_UPDATE_FAIL          15 // msgCtx = connection handle
#define BLE_EVBLEMSGID_CONN_TO_BONDED_MASTER           16 // msgCtx = connection handle
#define BLE_EVBLEMSGID_UPDATED_BOND                    17 // msgCtx = connection handle
#define BLE_EVBLEMSGID_ENCRYPTED                       18 // msgCtx = connection handle
#define BLE_EVBLEMSGID_POWER_FAILURE_WARNING           19 // msgCtx = current supply voltage
#define BLE_EVBLEMSGID_UNENCRYPTED                     20 // msgCtx = connection handle
#define BLE_EVBLEMSGID_DEVICENAME_WRITE                21 // msgCtx = connection handle 


//******************************************************************************
// Global Variable Declarations
//******************************************************************************
dim rc
dim stRsp$ as string        //Uart rx data is stored here
dim ok$,er$,pr$
dim urtcmd$                 // cmd line from uart
dim tkn$,tlen               // used by command parser
dim urts                    // will be <0 if uart parser suspended
dim i[NUM_OF_I_PARAMS]      // index 0 used for return values
dim hc[NUM_OF_CONNS+1]      // contains connection handles
dim conns                   // number of connections
dim name$					// device name
dim hz						// this is the handle of the current connection (currently used by --primary)
dim gcState                 // gatt client state, 0=IDLE, 1=TableMapping

dim prAddr$              	// BT address of last device pairing requested from or initiated with
dim hcSpp                   // handle of connection to use for VSP service
//******************************************************************************
// Initialisse Global Variable
//******************************************************************************

ok$    = "\nOK"
er$    = "\nERROR "
pr$    = "\r\n>"

urts=0 //not suspended

//==============================================================================
//==============================================================================
sub DbgMsg(byval msg$ as string)
  if (ENABLE_DEBUG_PRINTS!=0) then
    print "\n";msg$
  endif
endsub

//==============================================================================
//==============================================================================
sub DbgMsgVal(byval msg$ as string, byval vl as integer)
  if (ENABLE_DEBUG_PRINTS!=0) then
    print "\n";msg$;" ";vl
  endif
endsub

//-------------------------------------------------------------------------
//-------------------------------------------------------------------------
function ExtractIntTokens(u$,stIdx,num)
  while num>0
    tlen = ExtractIntToken(u$,i[stIdx])
    if tlen == 0 then
      exitfunc 4
    endif
    num=num-1
    stIdx = stIdx+1
  endwhile
endfunc 0

//==============================================================================
//==============================================================================
sub ShowConnParms(nCtx as integer)
  dim intrvl,sprvto,slat
  rc= BleGetCurConnParms(nCtx,intrvl,sprvto,slat)
  //AssertResCode(rc,1240)
  if rc==0 then
    DbgMsgVal("Conn Interval",intrvl)
    DbgMsgVal("Conn Supervision Timeout",sprvto)
    DbgMsgVal("Conn Slave Latency",slat)
  endif
endsub
//------------------------------------------------------------------------------
//** #include the correct library file for the smartBASIC module being used 
//------------------------------------------------------------------------------
// #include "lib\cmd.ble.def.sblib"            //comment out line below and uncomment this line if running on a single mode (BLE) module
//#include "lib\cmd.btc.manager.sblib"     //comment out line above and uncomment this line if running on a dual mode (BLE & BT Classic) module
#include "lib\cmd.bluez.manager.sblib"		//comment out lines above if you are using the bluez commands

//==============================================================================
//==============================================================================
sub UartRsp(rsp as integer)
  //if rsp == 0 then
    print pr$
  //elseif rsp > 0 then 
  //  print er$;integer.h' rsp;pr$
  //endif
  urts = rsp
endsub

//==============================================================================
//==============================================================================
sub InitBtDevice()
	
	dim nHandle
	
	name$ = SYSINFO$(4)
	name$ = right$(name$, 6)
	name$ = StrHexize$(name$)
	name$ = "bluez-" + name$
	rc = BTCSETFRIENDLYNAME (name$)			
	
	rc = BtcModeSet(9)							//Connectable and general discoverability
												//This should be altered from hciconfig later

	rc = btcSppOpen(nHandle)
endsub											
//==============================================================================
//==============================================================================
function _Help()
	print "\n Available Commands: "
	print "\n"
	print "\n		help"
	print "\n		hcitool"
	print "\n		gatttool"
	//PRINT "\n		quit\exit"
	print "\n"
	print "\nFor more information on the usage of each command use:"
	print "<command> --help"
endfunc 1

//==============================================================================
//==============================================================================
function _HciHelp()

	print "Usage:\n"
	print "	hcitool [options] <command> [command parameters]\n"
	print "Commands:\n"
	print "\n"
	print "	dev 		Display local devices\n"
	print "	inq 		Inquire remote devices\n"
//	print "	scan		Scan for remote devices\n"
//	print "	name		Get name from remote device\n"
//	print "	info		Get information from remote device\n"
//	print "	spinq		Start periodic inquiry\n"
//	print "	epinq		Exit periodic inquiry\n"
//	print "	cmd 		Submit arbitrary HCI commands\n"
	print "	con 		Display active connections\n"
	print "	cc  		Create connection to remote device\n"
	print "	dc  		Disconnect from remote device\n"
//	print "	sr  		Switch master/slave role\n"
//	print "	cpt 		Change connection packet type\n"
//	print "	rssi		Display connection RSSI\n"
//	print "	lq  		Display link quality\n"
//	print "	tpl 		Display transmit power level\n"
//	print "	afh 		Display AFH channel map\n"
//	print "	lp  		Set/display link policy settings\n"
//	print "	lst 		Set/display link supervision timeout\n"
	print "	auth		Request authentication\n"
	print "	enc 		Set connection encryption\n"
	print "	key         Change connection link key\n"
	print "	clkoff      Read clock offset\n"
	print "	clock       Read local or remote clock\n"
	print "	lescan      Start LE scan\n"
//	print "	lewladd     Add device to LE White List\n"
//	print "	lewlrm      Remove device from LE White List\n"
//	print "	lewlsz      Read size of LE White List\n"
//	print "	lewlclr     Clear LE White list\n"
	print "	lecc        Create a LE Connection\n"
	print "	ledc        Disconnect a LE Connection\n"
	print "	lecup       LE Connection Update\n"
	print "\n"
	print "For more information on the usage of each command use:\n"
	print "	hcitool <command> --help\n"
	
endfunc 1
//==============================================================================
//==============================================================================
function _GattHelp()
//
//Help Options:
//  -h, --help                                Show help options
//  --help-all                                Show all help options
//  --help-gatt                               Show all GATT commands
//  --help-params                             Show all Primary Services/Characteristics arguments
//  --help-char-read-write                    Show all Characteristics Value/Descriptor Read/Write arguments

	print "Usage:\n"
	print "  gatttool [OPTION...]\n"
	print "\n"
	print "GATT commands\n"
	print "	--primary                                 Primary Service Discovery\n"
	print "	--characteristics                         Characteristics Discovery\n"
	print "	--char-read                               Characteristics Value/Descriptor Read\n"
	print "	--char-write                              Characteristics Value Write Without Response (Write Command) \n"
	print "	--char-write-req                          Characteristics Value Write (Write Request)	\n"
	print "	--char-desc                               Characteristics Descriptor Discovery\n"
	print "	--listen                                  Listen for notifications and indications\n"
	print "	-I, --interactive                         Use interactive mode\n"
	print "\n"
	print "Application Options:\n"
	print "	-i, --adapter=hciX                        Specify local adapter interface\n"
	print "	-b, --device=MAC                          Specify remote Bluetooth address\n"
	print "	-t, --addr-type=[public | random]         Set LE address type. Default: public\n"
	print "	-m, --mtu=MTU                             Specify the MTU size\n"
	print "	-p, --psm=PSM                             Specify the PSM for GATT/ATT over BR/EDR\n"
	print "	-l, --sec-level=[low | medium | high]     Set security level. Default: low\n"
	print "	-I, --interactive                         Use interactive mode"

endfunc 1

//==============================================================================
//==============================================================================
function _HciCfgHelp() as integer
	
	print "Commands:\n"
	print "	up                 	Open and initialize HCI device\n"
	print "	down               	Close HCI device\n"
	print "	reset              	Reset HCI device\n"
	print "	rstat              	Reset statistic counters\n"
	print "	auth               	Enable Authentication\n"
	print "	noauth             	Disable Authentication\n"
	print "	encrypt            	Enable Encryption\n"
	print "	noencrypt          	Disable Encryption\n"
	print "	piscan             	Enable Page and Inquiry scan\n"
	print "	noscan             	Disable scan\n"
	print "	iscan              	Enable Inquiry scan\n"
	print "	pscan              	Enable Page scan\n"
	print "	ptype      [type]  	Get/Set default packet type\n"
	print "	lm         [mode]  	Get/Set default link mode\n"
	print "	lp         [policy]	Get/Set default link policy\n"
	print "	name       [name]  	Get/Set local name\n"
	print "	class      [class] 	Get/Set class of device\n"
	print "	voice      [voice] 	Get/Set voice setting\n"
	print "	iac        [iac]   	Get/Set inquiry access code\n"
	print "	inqtpl     [level] 	Get/Set inquiry transmit power level\n"
	print "	inqmode    [mode]  	Get/Set inquiry mode\n"
	print "	inqdata    [data]  	Get/Set inquiry data\n"
	print "	inqtype    [type]  	Get/Set inquiry scan type\n"
	print "	inqparms   [win:int]	Get/Set inquiry scan window and interval\n"
	print "	pageparms  [win:int]	Get/Set page scan window and interval\n"
	print "	pageto     [to]    	Get/Set page timeout\n"
	print "	afhmode    [mode]  	Get/Set AFH mode\n"
	print "	sspmode    [mode]  	Get/Set Simple Pairing Mode\n"
	print "	aclmtu     <mtu:pkt>	Set ACL MTU and number of packets\n"
	print "	scomtu     <mtu:pkt>	Set SCO MTU and number of packets\n"
	print "	putkey     <bdaddr>	Store link key on the device\n"
	print "	delkey     <bdaddr>	Delete link key from the device\n"
	print "	oobdata            	Display local OOB data\n"
	print "	commands           	Display supported commands\n"
	print "	features           	Display device features\n"
	print "	version            	Display version information\n"
	print "	revision           	Display revision information\n"
	print "	block      <bdaddr>	Add a device to the blacklist\n"
	print "	unblock    <bdaddr>	Remove a device from the blacklist\n"
	print "	lerandaddr <bdaddr>	Set LE Random Address\n"
	print "	leadv              	Enable LE advertising\n"
	print "	noleadv            	Disable LE advertising\n"
	print "	lestates           	Display the supported LE states\n"

endfunc 1
//==============================================================================
//==============================================================================
function AcqConnHandle(hConn)
  dim z
  for z=1 to (NUM_OF_CONNS)
    if hc[z] == -1 then
      hc[z]=hConn
      exitfunc z
    endif
  next
endfunc 0
//-------------------------------------------------------------------------
//#CMD#// advert report initadv   #INTstridx# #INTadflags# #INTadappearance# #INTmaxdevname#
//#CMD#// advert report initscn   #INTstridx#
//#CMD#// advert report ADuuid16  #INTstridx# #INTuuid0# #INTuuid1# #INTuuid2# #INTuuid3# #INTuuid4# #INTuuid5#
//#CMD#// advert report ADuuid128 #INTstridx# #INTuuidhandle#
//#CMD#// advert report ADany     #INTstridx# #INTtag# #HEXdata$#
//#CMD#// advert report commit    #INTstridx0# #INTstridx1#
//#CMD#// advert undirected       #INTintervalms# #INTtimeoutms# #INTfilterpolicy#
//#CMD#// advert scan             #INTintervalms# #INTtimeoutms# #INTfilterpolicy#
//#CMD#// advert nonconn          #INTintervalms# #INTtimeoutms# #INTfilterpolicy#
//#CMD#// advert directed         #INTintervalms# #INTtimeoutms# #INTfilterpolicy# #HEXaddr14Bytes#
//#CMD#// advert stop
//-------------------------------------------------------------------------
function _Hci()
	
	tlen = ExtractStrToken(urtcmd$,tkn$)
	if tlen == 0 THEN
		print "\nInsufficient parameters. For more information use"
		print "\nhcitool help"
		exitfunc 5			//Youssif: Here must display message need mroe parameters						//or display the whole help menu
	endif
	//=================================================
	if strcmp(tkn$,"help")==0 then
		rc = _HciHelp()
	endif
	
	if strcmp(tkn$,"dev")==0 then
		rc = _dev()								//Display the address of the local device
	endif
	
	if strcmp(tkn$,"inq")==0 then				
		rc = _inquiry()							//This function only needs to show the address of remote devices
	endif
	
	//if strcmp(tkn$,"scan")==0 then
	//	rc = _BtcScan()							//This function must show the address and name of remote devices
	//endif
	
	if strcmp(tkn$, "cc")==0 then
		rc = _sppConnect()						//This function should connect to an SPP device
	endif
	
	if strcmp(tkn$, "dc")==0 then
		rc = _sppDisconnect()
	endif
	
	if strcmp(tkn$, "auth")== 0 then
		rc = _auth()							//This is the equivalent of pair
	endif
	
	if strcmp(tkn$, "lescan")==0 then
		rc = _leScan()							//This function should show the addresses of Low Energy devices
	endif
	
	if strcmp(tkn$, "lecc")==0 then
		rc = _leConnect()
	endif
	
	if strcmp(tkn$, "ledc")==0 then
		rc = _leDisconnect()
	endif
	
endfunc 1
//-------------------------------------------------------------------------
//#CMD#// advert report initadv   #INTstridx# #INTadflags# #INTadappearance# #INTmaxdevname#
//#CMD#// advert report initscn   #INTstridx#
//#CMD#// advert report ADuuid16  #INTstridx# #INTuuid0# #INTuuid1# #INTuuid2# #INTuuid3# #INTuuid4# #INTuuid5#
//#CMD#// advert report ADuuid128 #INTstridx# #INTuuidhandle#
//#CMD#// advert report ADany     #INTstridx# #INTtag# #HEXdata$#
//#CMD#// advert report commit    #INTstridx0# #INTstridx1#
//#CMD#// advert undirected       #INTintervalms# #INTtimeoutms# #INTfilterpolicy#
//#CMD#// advert scan             #INTintervalms# #INTtimeoutms# #INTfilterpolicy#
//#CMD#// advert nonconn          #INTintervalms# #INTtimeoutms# #INTfilterpolicy#
//#CMD#// advert directed         #INTintervalms# #INTtimeoutms# #INTfilterpolicy# #HEXaddr14Bytes#
//#CMD#// advert stop
//-------------------------------------------------------------------------
function _Gatt()
	tlen = ExtractStrToken(urtcmd$,tkn$)
	if tlen == 0 THEN
		print "\nInsufficient parameters. For more information use"
		print "\ngatttool help"
		exitfunc 5		//Youssif: Here must display message need mroe parameters
	endif
	//=================================================
	if strcmp(tkn$,"help")==0 then
		rc = _GattHelp()
	endif

	if strcmp(tkn$,"primary")==0 then
		rc = _GattPrimary()
	endif	

	if strcmp(tkn$,"characteristics")==0 then
		rc = _GattChar()
	endif
endfunc 1
//-------------------------------------------------------------------------
//#CMD#// advert report initadv   #INTstridx# #INTadflags# #INTadappearance# #INTmaxdevname#
//#CMD#// advert report initscn   #INTstridx#
//#CMD#// advert report ADuuid16  #INTstridx# #INTuuid0# #INTuuid1# #INTuuid2# #INTuuid3# #INTuuid4# #INTuuid5#
//#CMD#// advert report ADuuid128 #INTstridx# #INTuuidhandle#
//#CMD#// advert report ADany     #INTstridx# #INTtag# #HEXdata$#
//#CMD#// advert report commit    #INTstridx0# #INTstridx1#
//#CMD#// advert undirected       #INTintervalms# #INTtimeoutms# #INTfilterpolicy#
//#CMD#// advert scan             #INTintervalms# #INTtimeoutms# #INTfilterpolicy#
//#CMD#// advert nonconn          #INTintervalms# #INTtimeoutms# #INTfilterpolicy#
//#CMD#// advert directed         #INTintervalms# #INTtimeoutms# #INTfilterpolicy# #HEXaddr14Bytes#
//#CMD#// advert stop
//-------------------------------------------------------------------------
function _HciCfg()
	tlen = ExtractStrToken(urtcmd$,tkn$)
	
	if tlen == 0 THEN
		print "\nInsufficient parameters. For more information use"
		print "\nhciconfig help"
		exitfunc 5		//Youssif: Here must display message need mroe parameters
	endif
	
	if strcmp(tkn$,"help")==0 then
		rc = _HciCfgHelp()
	endif
	
	if strcmp(tkn$,"auth")==0 then 
		print "Set the device to be pairable\n" 
		rc = BtcModeSet(0x0B)
	endif
	
endfunc 1

//==============================================================================
//==============================================================================
function OnUartCmd() as integer

	tlen = ExtractStrToken(urtcmd$,tkn$) //get first token
	
	if strcmp(tkn$,"hcitool")==0 then
		rc = _Hci()
      
    elseif strcmp(tkn$,"gatttool")==0 then
		rc = _Gatt()
	  
	elseif strcmp(tkn$,"hciconfig")==0 then
		rc = _HciCfg()
	  
	elseif strcmp(tkn$, "help")==0 then
		rc = _Help()
	
	elseif strcmp(tkn$,"exit")==0 || strcmp(tkn$,"quit")==0  then
      reset(0)
	
	elseif strcmp(tkn$,"")==0 then
		//exitfunc 1

	else
		print tkn$;": command not found\n"
	endif
	
	// send a response back to the user
	UartRsp(rc)
endfunc 1

//******************************************************************************
// Handler definitions
//******************************************************************************

//==============================================================================
// This handler is called when there is an inquiry report waiting to be read 
// Algorithm will prevent display of data from the same peer consecutively 
//==============================================================================
function HandlerInqResp(respType) as integer
	dim ad$,dta$,ndx,rsi,tag
	rc = BtcInquiryGetReport(ad$,dta$,ndx,rsi)
	print "\n		"; StrHexize$(ad$)
	
endfunc 1

//==============================================================================
// Called after an SPP connection attempt
//==============================================================================
function HandlerSppCon(hConn, res) as integer
    dim hz

    print "\n --- SPP Connect: (";integer.h' res;")"
    //if connected successfully
    if res == 0 then
        //try and acquire a connection handle
        hz = AcqConnHandle(hConn)
        
        //disconnect if failed
        if hz==0 then
            rc=BtcSppDisconnect(hConn)
            print " DROPPED"
        else
            hcSpp = hc[hz]     //always assume most recent connection for SPP
            conns = conns + 1
            print " handle = ";hz;pr$
        endif
    endif        
endfunc 1

//==============================================================================
// Called when a connection attempt to an SPP device times out
//==============================================================================
function HandlerSppConnTimOut() as integer
    print "\n --- SPP Conn Attempt Timeout"
endfunc 1

//==============================================================================
// Called when an SPP disconnection occurs
//==============================================================================
function HandlerSppDiscon(hConn)
    dim hz
    
    //hz = RelConnHandle(hConn)
    conns = conns - 1
    print "\n --- Spp Disconnect: handle=";hz
endfunc 1
//==============================================================================
// This handler is called when there is an inquiry timeout
//==============================================================================
function HandlerBtcInqTimOut() as integer 
	print "\nBtc Scanning stopped via timeout" 
	UartRsp(0)
endfunc 1

//==============================================================================
// Called when data is received via SPP
//==============================================================================
function HandlerSppData()
    dim hPort, data$, rLen
    
    '//read and print data while there is data available to read
    while BtcSppRead(hPort, data$, rLen) == 0    
        if rLen>0 then
            print"\nPort Handle: ";hPort; " Length: ";rLen;"\nData: ";data$;pr$
        endif
    endwhile
endfunc 1
//==============================================================================
// Called when there is a pairing request from another device
//==============================================================================
function HandlerPairReq()
	dim s$
    rc=BtcGetPAIRRequestBDAddr(s$)
    prAddr$ = s$
    print "\nPair Req: "; StrHexize$(s$);pr$
	rc = BtcSendPAIRResp(1)
endfunc 1

//==============================================================================
// Called on a pin request from another device
//==============================================================================
function HandlerPINReq() 

	dim mac$
    rc=BtcGetPinRequestBDAddr(mac$)
    if rc==0 then
        print "\nPIN Req: "; StrHexize$(mac$);pr$
    else
        //AssertResCode(rc,2273)
		print "Handler PIN Req is a problem\n"
    endif
endfunc 1

//==============================================================================
// Called after a pairing attempt
//==============================================================================
function HandlerPairRes(res)
    //print "Received the pin result\n"
	print "\nPair Result: ";res; " "; StrHexize$(prAddr$);pr$
endfunc 1

//==============================================================================
// This handler is called when there is an inquiry report waiting to be read 
// Algorithm will prevent display of data from the same peer consecutively 
//==============================================================================
function HandlerAdvRpt() as integer
  dim ad$,dta$,ndisc,rsi
  rc = BleScanGetAdvReport(ad$,dta$,ndisc,rsi)
  while rc==0
	ad$ = right$(ad$,8)
    print "\n ";strhexize$(ad$)
	//;" ";strhexize$(dta$);" ";ndisc;" ";rsi
    rc = BleScanGetAdvReport(ad$,dta$,ndisc,rsi)
  endwhile
endfunc 1
//==============================================================================
// This handler is called when there is a Ble scan timeout
//==============================================================================
function HandlerBlrScanTimOut() as integer 
	print "\nScanning stopped via timeout"
	UartRsp(0)
endfunc 1
//==============================================================================
// This handler is called when there is a BLE message
//==============================================================================
function HandlerBleMsg(BYVAL nMsgId AS INTEGER, BYVAL nCtx AS INTEGER) as integer
  //dim hz
  
  select nMsgId
  case BLE_EVBLEMSGID_CONNECT
    //hz = AcqConnHandle(nCtx)
    hz = nCtx
	//conns = conns + 1
    print "\n --- Connect: (";integer.h' nCtx;") handle=";hz
    if hz == 0 then
      //Could not store the handle so drop the connection
      rc = BleDisconnect(nCtx)
      print " DROPPED"
    else
      //accepted so display connection parameters
      ShowConnParms(nCtx)
      //always assume most recent connection for VSP
      //hcVsp = hc[hz]
    endif
    
  case BLE_EVBLEMSGID_DISCONNECT
    //hz = RelConnHandle(nCtx)
    conns = conns - 1
    print "\n --- Disconnect: (";integer.h' nCtx;") handle=";hz;pr$

  case BLE_EVBLEMSGID_DISPLAY_PASSKEY
    DbgMsgVal("Display Pairing Passkey ",nCtx)

  case BLE_EVBLEMSGID_NEW_BOND
    DbgMsg(" +++ New Bond")

  case BLE_EVBLEMSGID_UPDATED_BOND
    DbgMsg(" +++ Updated Bond")

  case BLE_EVBLEMSGID_ENCRYPTED
    DbgMsg(" +++ Encrypted Connection")

  case BLE_EVBLEMSGID_CONN_TO_BONDED_MASTER
    DbgMsgVal(" -- Conn to Bonded Master ",nCtx)

  case BLE_EVBLEMSGID_AUTH_KEY_REQUEST
    DbgMsgVal(" +++ Auth Key Request, type=",nCtx)

  case BLE_EVBLEMSGID_CONN_PARMS_UPDATE
    //ShowConnParms(nCtx)

  case BLE_EVBLEMSGID_CONN_PARMS_UPDATE_FAIL
    DbgMsg(" ??? Conn Parm Negotiation FAILED")

  case else
    DbgMsgVal("Unknown Ble Msg", nMsgId)
  endselect
endfunc 1
//==============================================================================
// This handler is called when a BLE device disconnects
//==============================================================================
function HndlrDiscon(nCtx,nRsn) as integer
	print "something must happen here\n"
endfunc 1 

//==============================================================================
//==============================================================================
function HandlerPrimSvc(hConn,hUuid,hStart,hEnd) as integer
  //select gcState
 // case 0
    print "\nEVDISCPRIMSVC("
  //  print "hConn=";integer.h' hConn;",hUuid=";integer.h' hUuid
  //  print ",hStart=";hStart;",hEnd=";hEnd;")"
    
  //case 1  //tablemapping
    //if hStart!=0 then
      // S: hStart,(hEnd),hUuid
      //print "\nS:";hStart;" ,(";hEnd;") ,";integer.h' hUuid
      // and get all characteristics of this service
      //rc=BleDiscCharFirst(hConn,0,hStart,hEnd)
      //if rc!=0 then
       // TerminateTableMap(rc)
      //endif
    //else
      //reached end of remote gatt table
      //TerminateTableMap(0)
    //endif
    
  //case else
  //endselect
endfunc 1

//==============================================================================
//==============================================================================


//==============================================================================
// This handler is called when data has arrived at the serial port
//==============================================================================
function HandlerUartRxCmd() as integer
	dim nMatch
	
	
	//Youssif: why is the 13 used?
	nMatch=UartReadMatch(stRsp$,13)
	if nMatch!=0 then
		//CR exists in the input buffer
		urtcmd$ = strsplitleft$(stRsp$, nMatch)
		exitfunc OnUartCmd()
	endif
endfunc 1

//******************************************************************************

//******************************************************************************
// Equivalent to main() in C
//******************************************************************************

//------------------------------------------------------------------------------
// Enable synchronous event handlers
//------------------------------------------------------------------------------
OnEvent  EVUARTRX					call HandlerUartRxCmd

OnEvent EVINQRESP					call HandlerInqResp
OnEvent	EVBTC_INQUIRY_TIMEOUT		call HandlerBtcInqTimOut	

OnEvent  EVSPPCON                 	call HandlerSppCon
OnEvent  EVBTC_SPP_CONN_TIMEOUT   	call HandlerSppConnTimOut
OnEvent  EVSPPDISCON              	call HandlerSppDiscon
OnEvent  EVBTC_SPP_DATA_RECIEVED  	call HandlerSppData

OnEvent  EVBTC_PAIR_REQUEST       	call HandlerPairReq
OnEvent  EVBTC_PIN_REQUEST        	call HandlerPinReq
OnEvent  EVBTC_PAIR_RESULT        	call HandlerPairRes

OnEvent EVBLE_ADV_REPORT			call HandlerAdvRpt
OnEvent  EVBLE_SCAN_TIMEOUT       	call HandlerBlrScanTimOut
OnEvent  EVBLEMSG                 	call HandlerBleMsg
OnEvent EvDiscon                  	call HndlrDiscon

OnEvent  EVDISCPRIMSVC            	call HandlerPrimSvc

//OnEvent 
//==============================================================================
//==============================================================================
sub Initialise()
	InitBtDevice()
	print "\nBLUETOOTH EXPLORTER v0.1\n"
endsub

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
Initialise()

UartRsp(rc)
//------------------------------------------------------------------------------
// Wait for a synchronous event.
// An application can have multiple <WaitEvent> statements
//------------------------------------------------------------------------------
WaitEvent