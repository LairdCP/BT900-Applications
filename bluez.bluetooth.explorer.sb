//******************************************************************************
// Laird Technologies (c) 2014
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++                                                                      ++
// +++++  When UwTerminal downloads the app it will store it as a filenname   ++
// +++++  which consists of all characters up to the first . and excluding it ++
// +++++                                                                      ++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// This library file provides commands to control BT Classic operation and should be
// #included into the file 'cmd.ble.manager.sb' if running on a dual mode module
// e.g. BT900.
//
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Convention : (1) Case sensitive, and commands are presented in alphabetic order
//              (2) If line ends with \ then it continues on next line. That does
//                  not mean that it should be sent as multiple lines
//              (3) Replace anything between ## 
//              (4) #INTaaaa# means a number in decimal, hex, octal or binary
//                      format -> 23 == 0x17 == h'17 == o'23 == b'10111
//                      aaaa is just a description
//              (5) #HEXaaaa# means a string without delimitors consisting of hex 
//                      characters only aaaa is just a description
//              (6) #STRaaaa# means a string without delimitors
//                      aaaa is just a description
//              (7) "STRaaaa" means a string which must have the " delimitor
//                      aaaa is just a description
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//******************************************************************************
// Definitions
//******************************************************************************

        //Set this to 0 to disable all debugging messages
#define ENABLE_DEBUG_PRINTS                  1

        // Number of connections
#define NUM_OF_CONNS                         8

//BLE EVENT MSG IDs
#define BLE_EVBLEMSGID_CONNECT                          0 // msgCtx = connection handle
#define BLE_EVBLEMSGID_DISCONNECT                       1 // msgCtx = connection handle
#define BLE_EVBLEMSGID_IMMEDIATE_ALERT_SERVICE_ALERT    2 // msgCtx = alert level
#define BLE_EVBLEMSGID_LINKLOSS_SERVICE_ALERT           3 // msgCtx = alert level
#define BLE_EVBLEMSGID_SERVICE_ERROR                    4 // msgCtx = resultcode
#define BLE_EVBLEMSGID_HTS_INDICATION_STATE             5 // msgCtx = new indication state 0=off, 1=on
#define BLE_EVBLEMSGID_HTS_INDICATION_CNF               6 // msgCtx = not used
#define BLE_EVBLEMSGID_BPS_INDICATION_STATE             7 // msgCtx = new indication state 0=off, 1=on
#define BLE_EVBLEMSGID_BPS_INDICATION_CNF               8 // msgCtx = not used
#define BLE_EVBLEMSGID_DISPLAY_PASSKEY                  9 // msgCtx = passcode to display
#define BLE_EVBLEMSGID_NEW_BOND                        10 // msgCtx = connection handle
#define BLE_EVBLEMSGID_AUTH_KEY_REQUEST                11 // msgCtx = 1 for passkey, 2 for 16 byte OOB data
#define BLE_EVBLEMSGID_HRS_NOTIFICATION_STATE          12 // msgCtx = new notification state 0=off, 1=on

//#define FUTURE_USE                                   13
#define BLE_EVBLEMSGID_CONN_PARMS_UPDATE               14 // msgCtx = connection handle
#define BLE_EVBLEMSGID_CONN_PARMS_UPDATE_FAIL          15 // msgCtx = connection handle
#define BLE_EVBLEMSGID_CONN_TO_BONDED_MASTER           16 // msgCtx = connection handle
#define BLE_EVBLEMSGID_UPDATED_BOND                    17 // msgCtx = connection handle
#define BLE_EVBLEMSGID_ENCRYPTED                       18 // msgCtx = connection handle
#define BLE_EVBLEMSGID_POWER_FAILURE_WARNING           19 // msgCtx = current supply voltage
#define BLE_EVBLEMSGID_UNENCRYPTED                     20 // msgCtx = connection handle
#define BLE_EVBLEMSGID_DEVICENAME_WRITE                21 // msgCtx = connection handle 

//BLUEZ COMMAND IDs: HCITOOL
#define BLUEZ_COMMAND_HCITOOL_DEV						1
#define BLUEZ_COMMAND_HCITOOL_INQ						2
#define BLUEZ_COMMAND_HCITOOL_SCAN						3
#define BLUEZ_COMMAND_HCITOOL_NAME						5
#define BLUEZ_COMMAND_HCITOOL_INFO						6
#define BLUEZ_COMMAND_HCITOOL_SPINQ						7
#define BLUEZ_COMMAND_HCITOOL_EPINQ						8
#define BLUEZ_COMMAND_HCITOOL_CMD						9
#define BLUEZ_COMMAND_HCITOOL_CON						10
#define BLUEZ_COMMAND_HCITOOL_CC						11
#define BLUEZ_COMMAND_HCITOOL_DC						12
#define BLUEZ_COMMAND_HCITOOL_SR						13
#define BLUEZ_COMMAND_HCITOOL_CPT						14
#define BLUEZ_COMMAND_HCITOOL_RSSI						15
//#define BLUEZ_COMMAND_HCITOOL_SCAN						16
#define BLUEZ_COMMAND_HCITOOL_LQ						17
#define BLUEZ_COMMAND_HCITOOL_TPL						18
#define BLUEZ_COMMAND_HCITOOL_AFH						19
#define BLUEZ_COMMAND_HCITOOL_LP						20
#define BLUEZ_COMMAND_HCITOOL_LST						21
#define BLUEZ_COMMAND_HCITOOL_AUTH						22
#define BLUEZ_COMMAND_HCITOOL_ENC						23
#define BLUEZ_COMMAND_HCITOOL_KEY						24
#define BLUEZ_COMMAND_HCITOOL_CLKOFF					25
#define BLUEZ_COMMAND_HCITOOL_CLOCK						26
#define BLUEZ_COMMAND_HCITOOL_LESCAN					27
#define BLUEZ_COMMAND_HCITOOL_LEWLADD					28
#define BLUEZ_COMMAND_HCITOOL_LEWLRM					29
#define BLUEZ_COMMAND_HCITOOL_LEWLSZ					30
#define BLUEZ_COMMAND_HCITOOL_LEWLCLR					31
#define BLUEZ_COMMAND_HCITOOL_LECC						32
#define BLUEZ_COMMAND_HCITOOL_LEDC						33
#define BLUEZ_COMMAND_HCITOOL_LECUP						34

//BLUEZ COMMAND IDs: GATTTOOL
#define BLUEZ_COMMAND_GATTTOOL_PRIMARY					41
#define BLUEZ_COMMAND_GATTTOOL_CHARACTERISTICS			42
#define BLUEZ_COMMAND_GATTTOOL_CHAR_READ				43
#define BLUEZ_COMMAND_GATTTOOL_CHAR_WRITE				44
#define BLUEZ_COMMAND_GATTTOOL_CHAR_WRITE_REQ			45
#define BLUEZ_COMMAND_GATTTOOL_CHAR_DESC				46
#define BLUEZ_COMMAND_GATTTOOL_LISTEN					47

//BLUEZ COMMAND IDs: RFCOMM
#define BLUEZ_COMMAND_RFCOMM_CONNECT					60

//APP RUN MODES
#define CMD_MODE                                 0
#define BRIDGE_SPP_MODE                          2


#define CAR_PRESS_DELAY                     100          //ms to wait between registering entries of '^'
//******************************************************************************
// Global Variable Declarations
//******************************************************************************
dim rc
dim stRsp$ 			        //Uart rx data is stored here
dim ok$,er$,pr$
dim urtcmd$                 // cmd line from uart
dim tkn$,tlen               // used by command parser
dim urts                    // will be <0 if uart parser suspended
dim hc[NUM_OF_CONNS+1]      // contains connection handles
dim conns                   // number of connections
dim name$					// local device name
dim addr$					// address of device being connected to

dim hz						// this is the handle of the current connection (currently used by --primary)
dim az						// this is the address of the current connected BT device
dim gcState                 // gatt client state, 0=IDLE, 1=TableMapping
dim sAttr
dim eAttr

dim prAddr$              				// BT address of last device pairing requested from or initiated with
dim hcSpp                   			// handle of connection to use for VSP service

dim command : command = 0				// Currently active BlueZ command
dim testhndl
dim inqtype	: inqtype = 0				// Inquiry Type: 0 General, 1 Limited
dim inqmode	: inqmode = 2				// Inquiry Mode: 0 for Standard, 1 for with RSSI, 2 for Extended)

dim inqtpl : inqtpl=4						// Inquiry transmit power level
dim mjVersion : mjVersion=0			// Major version number
dim mnVersion : mnVersion=82				// Minor version number

//******************************************************************************
// Initialise Global Variable
//******************************************************************************

ok$    = "\nOK"
er$    = "\nERROR "
pr$    = "------->"

urts = 0					// not suspended

//==============================================================================
//==============================================================================
sub AssertResCode(resCode)
	if rc !=0 then
		print "error: ";integer.h' rc;"\n"
	endif
endsub 
//==============================================================================
//==============================================================================
sub DbgMsg(byval msg$ as string)
  if (ENABLE_DEBUG_PRINTS!=0) then
    print "\n";msg$
  endif
endsub

//==============================================================================
//==============================================================================
sub DbgMsgVal(byval msg$ as string, byval vl as integer)
  if (ENABLE_DEBUG_PRINTS!=0) then
    print "\n";msg$;" ";vl
  endif
endsub

//==============================================================================
//==============================================================================
sub ShowConnParms(nCtx as integer)
  dim intrvl,sprvto,slat
  rc= BleGetCurConnParms(nCtx,intrvl,sprvto,slat)
  //AssertResCode(rc,1240)
  if rc==0 then
    DbgMsgVal("Conn Interval",intrvl)
    DbgMsgVal("Conn Supervision Timeout",sprvto)
    DbgMsgVal("Conn Slave Latency",slat)
  endif
endsub
//==============================================================================
// Initialise all connection handles
//==============================================================================
sub InitConnHandles()
  dim z
  for z=0 to (NUM_OF_CONNS)
    hc[z]=-1
  next
endsub
//==============================================================================
// Add the connection handle to the list of connection handles
//==============================================================================
function AcqConnHandle(hConn)
  dim z
  for z=1 to (NUM_OF_CONNS)
    if hc[z] == -1 then
	    hc[z]=hConn
      exitfunc z
    endif
  next

endfunc 0

//==============================================================================
// Release the connection handle from the array of conn handles
//==============================================================================
function RelConnHandle(hConn)
  dim z
  for z=1 to (NUM_OF_CONNS)
    if hc[z] == hConn then 
      hc[z]=-1
      exitfunc z
    endif
  next
endfunc 0
//------------------------------------------------------------------------------
//** #include the correct library file for the smartBASIC module being used 
//------------------------------------------------------------------------------
#include "lib\cmd.bluez.manager.sblib"		//comment out lines above if you are using the bluez commands

//==============================================================================
//==============================================================================
sub UartRsp(rsp as integer)
  //if rsp == 0 then
    print pr$
  //elseif rsp > 0 then 
  //  print er$;integer.h' rsp;pr$
  //endif
  urts = rsp
endsub

//==============================================================================
// Initialise the Bluetooth device
// Set the device to be disoverable, connectable, pairable, 
// Set the inquiry type to be general, inquiry mode to be extended
//==============================================================================
sub InitBtDevice()
	
	dim nHandle
	
	// Set the name of the local Bluetooth device
	name$ = SYSINFO$(4)
	name$ = right$(name$, 6)
	name$ = StrHexize$(name$)
	name$ = "bluez-" + name$
	rc = BTCSETFRIENDLYNAME (name$)
	AssertResCode(rc)
	
	// Set device is discoverable with 300s discoverability timeout
	rc = BtcSetDiscoverable(1, 300)
	AssertResCode(rc)
	
	// Set device to be connectable
	rc = BtcSetConnectable(1)
	AssertResCode(rc)
	
	// Set the device to be pairable
	rc = BtcSetPairable(1)
	AssertResCode(rc)				
												
	// Set inquiry type to be general
	rc = BtcInquiryConfig(0, inqtype)
	AssertResCode(rc)
	
	// Set inquiry mode to be extended
	rc = BtcInquiryConfig(1, inqmode)
	AssertResCode(rc)
	
	// Open Spp
	rc = btcSppOpen(nHandle)
	AssertResCode(rc)
	
endsub											
//==============================================================================
// Print the Help menu
//==============================================================================
function _Help()

	print "Available Commands: \n"
	print "\n"
	print "	help\n"
	print "	hcitool\n"
	print "	gatttool\n"
	print "	rfcomm\n"
	print "	hciconfig\n"
	print "	quit/exit\n"
	print "\n"
	print "For more information on the usage of each command use:\n"
	print "<command> --help\n\n"

endfunc 1

//==============================================================================
// print the hcitool help menu
//==============================================================================
function _HciHelp()

	print "Usage:\n"
	print "	hcitool <command> [command parameters]\n"
	print "\n"
	print "Commands:\n"
	print "	dev 		Display local devices\n"
	print "	inq 		Inquire remote devices\n"
	print "	scan		Scan for remote devices\n"
	print "	name		Get name from remote device\n"
	print "	con 		Display active connection handles\n"
	print "	cc  		Create connection to remote device\n"
	print "	dc  		Disconnect from remote device\n"
	print "	tpl 		Display transmit power level\n"
	print "	auth		Request authentication\n"
//	print "	enc 		Set connection encryption\n"
//	print "	key         Change connection link key\n"
//	print "	clkoff      Read clock offset\n"
//	print "	clock       Read local or remote clock\n"
	print "	lescan      Start LE scan\n"
	print "	lecc        Create a LE Connection\n"
	print "	ledc        Disconnect a LE Connection\n"
//	print "	lecup       LE Connection Update\n"
	print "\n"
	print "For more information on the usage of each command use:\n"
	print "	hcitool <command> --help\n\n"
	
endfunc 1
//==============================================================================
// Print the gatt help menu
//==============================================================================
function _GattHelp()
//
//Help Options:
//  -h, --help                                Show help options
//  --help-all                                Show all help options
//  --help-gatt                               Show all GATT commands
//  --help-params                             Show all Primary Services/Characteristics arguments
//  --help-char-read-write                    Show all Characteristics Value/Descriptor Read/Write arguments

	print "Usage:\n"
	print "  gatttool [OPTION...] <command>\n"
	print "\n"
	print "GATT commands\n"
	print "	--primary                                 Primary Service Discovery\n"
	print "	--characteristics                         Characteristics Discovery\n"
	print "	--char-read                               Characteristics Value/Descriptor Read\n"
	print "	--char-write                              Characteristics Value Write Without Response\n"
	print "	--char-write-req                          Characteristics Value Write \n"
	print "	--char-desc                               Characteristics Descriptor Discovery\n"
	print "	--listen                                  Listen for notifications and indications\n"
	//print "	-I, --interactive                         Use interactive mode\n"
	print "\n"
	print "Options:\n"
	//print "	-i, --adapter=hciX                        Specify local adapter interface\n"
	print "	-b, --device=MAC                          Specify remote Bluetooth address\n"
	//print "	-t, --addr-type=[public | random]         Set LE address type. Default: public\n"
	//print "	-m, --mtu=MTU                             Specify the MTU size\n"
	//print "	-p, --psm=PSM                             Specify the PSM for GATT/ATT over BR/EDR\n"
	//print "	-l, --sec-level=[low | medium | high]     Set security level. Default: low\n"
	//print "	-I, --interactive                         Use interactive mode\n"
	print "\n"
	
endfunc 1

//==============================================================================
// Print the hciconfig help menu
//==============================================================================
function _HciCfgHelp() as integer
	
	print "Commands:\n"
	//print "	up                 	Open and initialize HCI device\n"
	//print "	down               	Close HCI device\n"
	//print "	reset              	Reset HCI device\n"
	//print "	rstat              	Reset statistic counters\n"
	//print "	auth               	Enable Authentication\n"
	//print "	noauth             	Disable Authentication\n"
	//print "	encrypt            	Enable Encryption\n"
	//print "	noencrypt          	Disable Encryption\n"
	print "	piscan             	Enable Page and Inquiry scan\n"
	print "	noscan             	Disable scan\n"
	print "	iscan              	Enable Inquiry scan\n"
	print "	pscan              	Enable Page scan\n"
	//print "	ptype      [type]  	Get/Set default packet type\n"
	//print "	lm         [mode]  	Get/Set default link mode\n"
	//print "	lp         [policy]	Get/Set default link policy\n"
	print "	name       [name]  	Get/Set local name\n"
	//print "	class      [class] 	Get/Set class of device\n"
	//print "	voice      [voice] 	Get/Set voice setting\n"
	//print "	iac        [iac]   	Get/Set inquiry access code\n"
	print "	inqtpl     [level] 	Get/Set inquiry transmit power level\n"
	print "	inqmode    [mode]  	Get/Set inquiry mode\n"
	//print "	inqdata    [data]  	Get/Set inquiry data\n"
	print "	inqtype    [type]  	Get/Set inquiry scan type\n"
	//print "		inqparms   [win:int]	Get/Set inquiry scan window and interval\n"
	//print "		pageparms  [win:int]	Get/Set page scan window and interval\n"
	//print "		pageto     [to]    	Get/Set page timeout\n"
	//print "		afhmode    [mode]  	Get/Set AFH mode\n"
	//print "		sspmode    [mode]  	Get/Set Simple Pairing Mode\n"
	//print "		aclmtu     <mtu:pkt>	Set ACL MTU and number of packets\n"
	//print "		scomtu     <mtu:pkt>	Set SCO MTU and number of packets\n"
	//print "		putkey     <bdaddr>	Store link key on the device\n"
	//print "		delkey     <bdaddr>	Delete link key from the device\n"
	//print "		oobdata            	Display local OOB data\n"
	//print "		commands           	Display supported commands\n"
	//print "		features           	Display device features\n"
	print "	version            	Display version information\n"
	//print "		revision           	Display revision information\n"
	//print "		block      <bdaddr>	Add a device to the blacklist\n"
	//print "		unblock    <bdaddr>	Remove a device from the blacklist\n"
	//print "		lerandaddr <bdaddr>	Set LE Random Address\n"
	//print "		leadv              	Enable LE advertising\n"
	//print "		noleadv            	Disable LE advertising\n"
	//print "		lestates           	Display the supported LE states\n\n"
	print "\n"

endfunc 1
//==============================================================================
// Print the rfcomm help menu
//==============================================================================
function _rfcommHelp()

	print "Usage:\n"
	print "      rfcomm [options] <command> <dev>\n"
	print "\nCommands:\n"
	//print " 	release  <dev>                   	Release device\n"
	//print " 	show     <dev>                   	Show device\n"
	print "      connect     Connect device\n"
	//print " 	listen   <dev> [channel [cmd]]   	Listen\n"
	//print " 	watch    <dev> [channel [cmd]]   	Watch\n"
	print "      write       Write data to device\n\n"
	print "      bind        Bind device\n"
	print "\nOptions:\n"
	//print " 	-i [hciX|bdaddr]      Local HCI device or BD Address\n"
	print "      --help      Display help\n"
	//print " 	-r, --raw             Switch TTY into raw mode\n"
	//print " 	-A, --auth            Enable authentication\n"
	//print " 	-E, --encrypt         Enable encryption\n"
	//print " 	-S, --secure          Secure connection\n"
	//print " 	-M, --master          Become the master of a piconet\n"
	//print " 	-f, --config [file]   Specify alternate config file\n"
	//print " 	-a                    Show all devices (default)\n"
	print "      --handle    Connection Handle\n"
	print "      --data      Data to write\n"
	print "\n"

endfunc 1
//==============================================================================
// Extract the hcitool command
//==============================================================================
function _Hci()
	
	while ExtractStrToken(urtcmd$, tkn$)!=0
		//=================================================
		if strcmp(tkn$,"help")==0 then
			rc = _hciHelp()
			exitfunc 1
	
		elseif strcmp(tkn$,"dev")==0 then
			// Display the address of the local device
			rc = _hciDev()								
	
		elseif strcmp(tkn$,"inq")==0 then				
			command = BLUEZ_COMMAND_HCITOOL_INQ
			// Inquire for remote devices (show address only)
			rc = _hciInq()							
	
		elseif strcmp(tkn$,"scan")==0 then
			// Scan for remote devices (show address and name)
			command = BLUEZ_COMMAND_HCITOOL_SCAN
			rc = _hciScan()							
	
		elseif strcmp(tkn$,"name")==0 then
			// Get name from remote device
			command = BLUEZ_COMMAND_HCITOOL_NAME
			rc = _hciName()							

		elseif strcmp(tkn$,"con")==0 then
			// Display active connection handles
			command = BLUEZ_COMMAND_HCITOOL_CON
			rc = _hciCon()							
	
	
		elseif strcmp(tkn$, "cc")==0 then
			// Create connection to remote device
			command = BLUEZ_COMMAND_HCITOOL_CC
			rc = _hciCc()
	
		elseif strcmp(tkn$, "dc")==0 then
			// Disconnect from remote device
			command = BLUEZ_COMMAND_HCITOOL_DC
			rc = _hciDc()
	
		elseif strcmp(tkn$, "auth")== 0 then
			// Request authentication
			rc = _hciAuth()
	
		elseif strcmp(tkn$, "lescan")==0 then
			// Start LE scan
			rc = _hciLeScan()
	
		elseif strcmp(tkn$, "lecc")==0 then
			// Create a LE connection
			rc = _hciLeCc()
	
		elseif strcmp(tkn$, "ledc")==0 then
			// Disconnect a LE Connection
			rc = _hciLeDc()
			
		else 
			print "Unknown command - \22";tkn$;"\22\n"
		endif
		
	endwhile
	
endfunc 1
//==============================================================================
// Extract the gatttool command
//==============================================================================
function _Gatt()

	dim s$
	s$ = urtcmd$
	while ExtractStrToken(s$, tkn$)!= 0
		//tlen = ExtractStrToken(urtcmd$,tkn$)
		//if tlen == 0 then
			//print "\nInsufficient parameters. For more information use"
			//print "\ngatttool help\n"
			//exitfunc 5		//Youssif: Here must display message need mroe parameters
		//endif
		//=================================================
		if strcmp(tkn$,"help")==0 then
			rc = _GattHelp()
			exitfunc 1

		elseif strcmp(tkn$,"primary")==0 then
			command = BLUEZ_COMMAND_GATTTOOL_PRIMARY
			rc = _GattPrimary()

		elseif strcmp(tkn$,"characteristics")==0 then
			command = BLUEZ_COMMAND_GATTTOOL_CHARACTERISTICS
			rc = _GattChar()
	
		elseif strcmp(tkn$, "char")==0 then 
			strshiftleft(s$, 1)
			rc = ExtractStrToken(s$, tkn$)
			if strcmp(tkn$, "read")==0 then
				command = BLUEZ_COMMAND_GATTTOOL_CHAR_READ
				rc = _GattCharRead()
			elseif strcmp(tkn$, "write")==0 then
				command = BLUEZ_COMMAND_GATTTOOL_CHAR_WRITE
				rc = _GattCharWrite()
			elseif strcmp(tkn$, "desc")==0 then
				command = BLUEZ_COMMAND_GATTTOOL_CHAR_DESC
				rc = _GattCharDesc()
			endif
		
		else 
			print "Unknown command - \22";tkn$;"\22\n"
		
		endif
	endwhile

endfunc 1
//==============================================================================
// Extract the hciconfig command
//==============================================================================
function _HciCfg()
	
	dim s$, val
	s$ = urtcmd$
	while ExtractStrToken(s$, tkn$)!= 0
		//tlen = ExtractStrToken(urtcmd$,tkn$)
	
		//if tlen == 0 then
		//print "\nInsufficient parameters. For more information use"
		//print "\nhciconfig help"
		//exitfunc 5		//Youssif: Here must display message need mroe parameters
		//endif
	
		if strcmp(tkn$,"help")==0 then
			rc = _HciCfgHelp()
			exitfunc 1
	
		elseif strcmp(tkn$,"auth")==0 then 
			print "Set the device to be pairable\n" 
			rc = BtcSetConnectable(1)
			AssertResCode(rc)
			rc = BtcSetPairable(1)
			AssertResCode(rc)
	
		elseif strcmp(tkn$,"name")==0 then 
			tlen = ExtractStrToken(s$,tkn$)
			if tlen == 0 then
				rc = BtcGetFriendlyName(s$)
				AssertResCode(rc)
				print "\n";s$;"\n"
			else
				name$ = tkn$ + s$
				rc = BtcSetFriendlyName(name$)
				AssertResCode(rc)
				exitfunc 1
			endif
	
		elseif strcmp(tkn$,"piscan")==0 then 
			//Enable inquiry scan and page scan (default)
			rc = BtcSetDiscoverable(1, 300)
			AssertResCode(rc)
			rc = BtcSetConnectable(1)
			AssertResCode(rc)
	
		elseif strcmp(tkn$,"pscan")==0 then 
			//Enable page scan
			rc = BtcSetConnectable(1)
			AssertResCode(rc)
	
		elseif strcmp(tkn$,"iscan")==0 then 
			//Enable inquiry scan
			rc = BtcSetDiscoverable(1, 300)
			AssertResCode(rc)
	
		elseif strcmp(tkn$,"noscan")==0 then 
			//The adapter in not detectable by other devices and will not accept any incoming connections
			rc = BtcSetDiscoverable(0, 300)
			AssertResCode(rc)
			rc = BtcSetConnectable(0)
			AssertResCode(rc)
		
		elseif strcmp(tkn$, "inqtpl")==0 then
			// Get/set the transmit power level
			if ExtractStrToken(s$, tkn$) == 0  then
				// Get the transmit power level
				print "Inquiry transmit power level : ";inqtpl;"\n"
			else 
				// Set the transmit power level
				if strcmp(tkn$,"-")==0 then
					rc = ExtractStrToken(s$, tkn$)
					val = StrValDec(tkn$)
					if (val > 70) then
						print "Invalid power value. Valid range is from -70 to 20 dBm\n"
					else
						inqtpl = val*-1
					endif
				else
					if (val > 20) then
						print "Invalid power value. Valid range is from -70 to 20 dBm\n"
					else
						inqtpl =  val
					endif
				endif
				rc = BtcInquiryConfig(3,inqtpl)
				AssertResCode(rc)
			endif
		
		elseif strcmp(tkn$,"inqmode")==0 then 
			//Get/Set Inquiry mode
			if ExtractStrToken(s$, tkn$) == 0  then
				// Get inquiry mode
				if inqmode == 0 then
					print "Inquiry mode: Standard Inquiry\n"
				elseif inqmode == 1 then
					print "Inquiry mode: Inquiry with RSSI\n"
				elseif inqmode == 2 then
					print "Inquiry mode: Inquiry with RSSI or Extended Inquiry\n"
				else
					print "Invalid inquiry mode detected. Please set inquiry mode to 0, 1, or 2\n"
				endif
			else
				val = StrValDec(tkn$)
				if val >= 0 && val < 3 then
					inqmode = val
					rc = BtcInquiryConfig(1, inqmode)
					AssertResCode(rc)
				else 
					print "Invalid inquiry mode. Valid values are 0, 1, and 2\n"
				endif
			endif
		
		elseif strcmp(tkn$,"inqtype")==0 then 
			//Get/Set Inquiry type
			if ExtractStrToken(s$, tkn$) == 0  then
				// Get inquiry type
				if inqtype == 0 then
					print "Inquiry scan type: General Inquiry Scan\n"
				elseif inqtype == 1 then
					print "Inquiry scan type: Limited Inquiry Scan\n"
				else
					print "Invalid inquiry type detected. Please set inquiry type to 0, or 1\n"
				endif
			else
				val = StrValDec(tkn$)
				if val >= 0 && val < 2 then
					inqtype = val
					rc = BtcInquiryConfig(0, inqtype)
					AssertResCode(rc)
				else 
					print "Invalid inquiry type. Valid values are 0 and 1\n"
				endif
			endif
		
		elseif strcmp(tkn$, "version")==0 then
			dim fw, W, X, Y, Z
			fw = SYSINFO(3)
			print "\nApp Version: BlueZ Version ";mjVersion;".";mnVersion;"\n"
			print "Device Name: ";BleGetDeviceName$();"\n"
			print "Firmware: ";W;".";X;".";Y;".";Z;"\n"
			print "Manufacturer: Laird Technologies\n"
			
		else 
			print "Unknown command - \22";tkn$;"\22\n"
		
		endif
	endwhile
	
endfunc 1
//==============================================================================
// Extract the rfcomm command
//==============================================================================
function _rfcomm()
	
	tlen = ExtractStrToken(urtcmd$,tkn$)
	if strcmp(tkn$, "help")==0 then
		rc = _rfcommHelp()
		exitfunc 1

	elseif strcmp(tkn$, "connect")==0 then
		command = BLUEZ_COMMAND_RFCOMM_CONNECT
		rc = _rfcommConnect()
	
	elseif strcmp(tkn$, "write")==0 then
		rc = _rfcommWrite()
	
	elseif strcmp(tkn$, "bind")==0 then
		rc = _rfcommBind()
		
	else
		print "Unknown command - \22";tkn$;"\22\n"
	
	endif
	
endfunc 1
//==============================================================================
// Extract the received Uart command
//==============================================================================
function OnUartCmd() as integer

	tlen = ExtractStrToken(urtcmd$,tkn$) //get first token
	
	if strcmp(tkn$,"hcitool")==0 then
		rc = _Hci()
      
    elseif strcmp(tkn$,"gatttool")==0 then
		rc = _Gatt()
	  
	elseif strcmp(tkn$,"hciconfig")==0 then
		rc = _HciCfg()
		
	elseif strcmp(tkn$, "rfcomm")==0 then
		rc = _rfcomm()
	  
	elseif strcmp(tkn$, "help")==0 then
		rc = _Help()
	
	elseif strcmp(tkn$,"exit")==0 || strcmp(tkn$,"quit")==0  then
      reset(0)
	
	elseif strcmp(tkn$,"")==0 then
		//exitfunc 1

	else
		print tkn$;": command not found\n"
	endif
	
	// send a response back to the user
	//UartRsp(rc)
	print pr$
	
endfunc 1

//******************************************************************************
// Handler definitions
//******************************************************************************

//==============================================================================
// This handler is called when there is an inquiry report waiting to be read 
// Algorithm will prevent display of data from the same peer consecutively 
//==============================================================================
function HandlerInqResp(respType) as integer
	
	dim ad$,dta$,ndx,rsi,tag, name$
	
	// Get the report from the inquiry response
	rc = BtcInquiryGetReport(ad$,dta$,ndx,rsi)
	
	if command == BLUEZ_COMMAND_HCITOOL_INQ then
		print "\n		"; StrHexize$(ad$)
			
	elseif command == BLUEZ_COMMAND_HCITOOL_SCAN then
		print "\n		"; StrHexize$(ad$)
		if respType == 2 then
			//Get local name
			tag = 0x09
			rc=BtcGetEIRbyTag(dta$, tag, name$)
			//AssertResCode(rc)
			if rc == 0x5703 then
				tag = 0x08
				rc=BtcGetEIRbyTag(dta$, tag, name$)
				//AssertResCode(rc)
			endif
				
			if rc == 0 then
				print "  ";name$
			endif		
		else
			print "  n/a"
		endif
		
	elseif command == BLUEZ_COMMAND_HCITOOL_NAME then
		// Only looking for name of specified address
		if strcmp(ad$, addr$)!=0 then
			exitfunc 1
			
		else
			print "\n		"; StrHexize$(ad$)
			if respType == 2 then
				//Get local name
				tag = 0x09
				rc=BtcGetEIRbyTag(dta$, tag, name$)
				if rc == 0x5703 then
					tag = 0x08
					rc=BtcGetEIRbyTag(dta$, tag, name$)
				endif
				
				if rc == 0 then
					print "  ";name$
				endif		
			
			else
				print "  n/a"
			endif
		// Found the device so cancel inquiry
		rc = BtcInquiryCancel()
		AssertResCode(rc)
		endif
	endif
	
endfunc 1
//==============================================================================
// Called after an SPP connection attempt
//==============================================================================
function HandlerSppCon(hConn, res) as integer
	dim hz, az
    //if connected successfully
	if res == 0 then
		hz = AcqConnHandle(hConn)
		conns = conns + 1
		if command == BLUEZ_COMMAND_RFCOMM_CONNECT then
			print "\nrfcomm connected. Connection handle: ";hConn;"\n";pr$
		else 
			print "\nConnected\n";pr$
		endif
	else
		print "\nrfcomm connection failed: ";res;"\n";pr$
    endif        
endfunc 1
//==============================================================================
// Called when a connection attempt to an SPP device times out
//==============================================================================
function HandlerSppConnTimOut() as integer
    print "\n --- SPP Conn Attempt Timeout"
endfunc 1
//==============================================================================
// Called when an SPP disconnection occurs
//==============================================================================
function HandlerSppDiscon(hConn)
    dim hz, az
    hz = RelConnHandle(hConn)
    conns = conns - 1
    print "\nDisconnected\n";pr$ 
endfunc 1
//==============================================================================
// This handler is called when there is an inquiry timeout
//==============================================================================
function HandlerBtcInqTimOut() as integer 
	//print "\nInquiry stopped via timeout\n"
	print "\n";pr$
	//UartRsp(0)
endfunc 1
//==============================================================================
// Called when data is received via SPP
//==============================================================================
function HandlerSppData()
    dim hPort, data$, rLen
    '//read and print data while there is data available to read
	while BtcSppRead(hPort, data$, rLen) == 0    
        if rLen>0 then
            //print"\nPort Handle: ";hPort; " Length: ";rLen;"\nData: ";data$;pr$
			print "\nrfcomm data: ";data$;"\n";pr$
        endif
    endwhile
endfunc 1
//==============================================================================
// Called when data is received via SPP in bridge mode
//==============================================================================
function HandlerSppDataBridge()
    dim hPort, data$, rLen
    
    '//read and print data while there is data available to read
    while BtcSppRead(hPort, data$, rLen) == 0    
        if rLen>0 then
            print data$
        endif
    endwhile
endfunc 1
//==============================================================================
// Called when there is a pairing request from another device
//==============================================================================
function HandlerPairReq()
	
	dim s$
    rc=BtcGetPAIRRequestBDAddr(s$)
    prAddr$ = s$
    //print "\nPair Req: "; StrHexize$(s$);" \n"
	rc = BtcSendPAIRResp(1)
	AssertResCode(rc)
	
endfunc 1
//==============================================================================
// Called on a pin request from another device
//==============================================================================
function HandlerPINReq() 

	dim mac$
    rc=BtcGetPinRequestBDAddr(mac$)
	AssertResCode(rc)
    if rc==0 then
        print "PIN Req: "; StrHexize$(mac$);pr$;"\n"
    else
        //AssertResCode(rc,2273)
		print "Handler PIN Req is a problem\n"
    endif
endfunc 1
//==============================================================================
// Called after a pairing attempt
//==============================================================================
function HandlerPairRes(res)
    //print "Received the pin result\n"
	//print "Pair Result: ";res; " "; StrHexize$(prAddr$);"\n"
endfunc 1
//==============================================================================
// This handler is called when there is an inquiry report waiting to be read 
// Algorithm will prevent display of data from the same peer consecutively 
//==============================================================================
function HandlerAdvRpt() as integer
	dim ad$,dta$,ndisc,rsi,tag, nm$
	rc = BleScanGetAdvReport(ad$,dta$,ndisc,rsi)
	AssertResCode(rc)
	while rc==0
		ad$ = right$(ad$,8)
		print "\n		";strhexize$(ad$)
		//;"  ";StrEscape$(dta$)
		//;" ";strhexize$(dta$);" ";ndisc;" ";rsi
		tag = 0x09
		rc = BLEGETADBYTAG(dta$, tag, nm$)
		if rc == 0x6060 then
			tag = 0x08
			rc = BLEGETADBYTAG(dta$, tag, nm$)
			AssertResCode(rc)
		endif
				
		if rc == 0 then
			print "  ";nm$
		endif
		//else
		//	print "  n/a"
		rc = BleScanGetAdvReport(ad$,dta$,ndisc,rsi)
	endwhile
endfunc 1
//==============================================================================
// This handler is called when there is a Ble scan timeout
//==============================================================================
function HandlerBlrScanTimOut() as integer 
	//print "\nScanning stopped via timeout\n"
	//UartRsp(0)
	print "\n";pr$
endfunc 1
//==============================================================================
// This handler is called when there is a BLE message
//==============================================================================
function HandlerBleMsg(BYVAL nMsgId AS INTEGER, BYVAL nCtx AS INTEGER) as integer
  dim hz, az
  
  select nMsgId
  case BLE_EVBLEMSGID_CONNECT
    hz = AcqConnHandle(nCtx)
	conns = conns + 1
    print "\nConnected\n";pr$
	
    if hz == 0 then
      //Could not store the handle so drop the connection
      rc = BleDisconnect(nCtx)
	  AssertResCode(rc)
    else
      //accepted so display connection parameters
      //ShowConnParms(nCtx)
      //always assume most recent connection for VSP
      //hcVsp = hc[hz]
    endif
    
  case BLE_EVBLEMSGID_DISCONNECT
    // here must get address from the handle
	hz = RelConnHandle(nCtx)
    conns = conns - 1
    print "\nDisconnected\n";pr$

  case BLE_EVBLEMSGID_DISPLAY_PASSKEY
    DbgMsgVal("Display Pairing Passkey ",nCtx)

  case BLE_EVBLEMSGID_NEW_BOND
    DbgMsg(" +++ New Bond")

  case BLE_EVBLEMSGID_UPDATED_BOND
    DbgMsg(" +++ Updated Bond")

  case BLE_EVBLEMSGID_ENCRYPTED
    DbgMsg(" +++ Encrypted Connection")

  case BLE_EVBLEMSGID_CONN_TO_BONDED_MASTER
    DbgMsgVal(" -- Conn to Bonded Master ",nCtx)

  case BLE_EVBLEMSGID_AUTH_KEY_REQUEST
    DbgMsgVal(" +++ Auth Key Request, type=",nCtx)

  case BLE_EVBLEMSGID_CONN_PARMS_UPDATE
    //ShowConnParms(nCtx)

  case BLE_EVBLEMSGID_CONN_PARMS_UPDATE_FAIL
    DbgMsg(" ??? Conn Parm Negotiation FAILED")

  case else
    DbgMsgVal("Unknown Ble Msg", nMsgId)
  endselect
endfunc 1
//==============================================================================
// This handler is called when a BLE primary service is discovered
//==============================================================================
function HandlerPrimSvc(hConn,hUuid,hStart,hEnd) as integer
  //select gcState
 // case 0
	sAttr = hStart
	eAttr = hEnd
	if command == BLUEZ_COMMAND_GATTTOOL_PRIMARY then
		print "\n" 
		print "attr handle = 0x";integer.h' hStart
		print ", end grp handle = 0x";integer.h' hEnd
		print ", uuid = ";integer.h' hUuid
		rc = BleDiscServiceNext(hz)
		if rc != 0 then 
			print "\n";pr$
			BleGattcClose()
			exitfunc 1 
		endif
	
	elseif command == BLUEZ_COMMAND_GATTTOOL_CHARACTERISTICS then
		rc = BleDiscCharFirst(hz,0,sAttr,eAttr)
		AssertResCode(rc)
	endif
	
	
endfunc 1
//==============================================================================
// This handler is called when a BLE characteristic is discovered
//==============================================================================
function HandlerCharDisc(hConn,hUuid,cProp,hVal,hiUuid) as integer

	if hUuid != 0 then
		print "\n"
		print "handle = 0x";integer.h' hVal-1
		print ", char properties = 0x";integer.h' cProp
		print ", char value handle = 0x";integer.h' hVal
		print ", uuid = ";integer.h' hUuid
	endif
	
	rc = BleDiscCharNext(hz)
	if rc != 0 then
		rc = BleDiscServiceNext(hz)
		if rc !=0 then
			print "\n";pr$
			BleGattcClose()
		endif
	endif
	
endfunc 1
//==============================================================================
// This handler is called when a BLE descriptor is discovered
//==============================================================================
function HandlerDescDisc(hChar, hUuid, hDisc) as integer
	print "\nEVDISC"
	print "\nhChar ";integer.h' hChar
	print "\nhUuid ";integer.h' hUuid
	print "\nhDisc ";integer.h' hDisc
	
	rc = BleDiscDescNext(hChar)
	if rc !=0 then
		print "OVER\n";pr$
		BleGattcClose()
	endif
	
endfunc 1
//==============================================================================
// This handler is called when a BLE characteristic attribute has been read
//==============================================================================
function HandlerAttrRead(hConn,hAttr,nSts) as integer

	dim a$,ofst  
	if nSts == 0 then
		rc = BleGattcReadData(hConn,testhndl,ofst,a$)
		if rc==0 then
			print "\nCharacteristic value/descriptor: "
			print "";StrHexize$(a$)
			print " (";StrEscape$(a$);") \n";pr$
		else	
			AssertResCode(rc)
		endif
	
	else 
		print "nSts is not 0 \n"									//Must print correct error message here
	endif  
	BleGattcClose()
	
endfunc 1
//==============================================================================
// This handler is called when a BLE characteristic attribute has been written to 
//==============================================================================
function HandlerAttrWrite(hConn,aHndl,nSts) as integer
    
	if nSts == 0 then
		print "Characteristic value was written successfully\n"
	else 
		print "\nStatus  : ";integer.h' nSts
		print "\nCharacteristic write failed: Attribute Can't be written\n";pr$		//Different error messages should be printed for different nSts
	endif
	
	//"Characteristic value was written successfully" should be printed if sec level must be increased
endfunc 1
//==============================================================================
// This handler is called when there is data notified or indicated
//==============================================================================
function HandlerAttrNtfyCmd() as integer
  dim hConn,hAttr,att$,dscd
  print "\nEVATTRNOTIFY()"
  do
    rc=BleGattcNotifyRead(hConn,hAttr,att$,dscd)
    if rc==0 then
      print "\n >BleGattcNotifyRead("
      print "hConn=";integer.h' hConn;",handle=";hAttr;",Dumped=";dscd
      print ",data=";StrHexize$(att$);")"
    endif
  dowhile rc==0
endfunc 1
//==============================================================================
// This handler is called when data has arrived at the serial port
//==============================================================================
function HandlerUartRxCmd() as integer
	dim nMatch
	
	
	//Youssif: why is the 13 used?
	nMatch=UartReadMatch(stRsp$,13)
	if nMatch!=0 then
		//CR exists in the input buffer
		urtcmd$ = strsplitleft$(stRsp$, nMatch)
		exitfunc OnUartCmd()
	endif
endfunc 1
//==============================================================================
// Called when data is received via UART when bridged to SPP
//==============================================================================
function HandlerUartRxSpp()
    
	dim uLen, u$, nLen, nLen2 : uLen = 1
	dim carCnt                  //count variable for number of times '^' entered
    WHILE uLen != 0
        //read data that has arrived through via the UART
        uLen = UartRead(u$) 
    
        if uLen > 0 then
            if StrCmp(u$,"^")==0 then
                // print "\nBefore: ";carCnt                 
                if TimerRunning(0)==0 then
                    carCnt = carCnt + 1
                    if carCnt<3 then
                        TimerStart(0,CAR_PRESS_DELAY,0) 
                    else
                        rc=SendMsgApp(0,CMD_MODE)    //* Using this for switching between bridge and cmd mode
                    endif
                else    //invalid press                    
                    TimerCancel(0)
                    carCnt = 0
                endif
            else
                //write data to most recent spp connection
                nLen2 = 0
                WHILE nLen2 != uLen
                    rc = BtcSPPWrite(hcSpp, u$, nLen)
                    IF rc != 0 THEN
                        //Assume problem with the SPP connection
                        exitfunc rc
                    ENDIF
                    STRSHIFTLEFT(u$, nLen)
                    nLen2 = nLen2 + nLen
                ENDWHILE
            endif
        endif
    ENDWHILE
endfunc 1

//* Using this instead of HandlerSio28 to switch modes
'//==============================================================================
'// Called after SendMsgApp is called. Used to switch between command and bridge mode
'//==============================================================================
function SetMode(msgID, cmd) as integer
        
    if cmd==CMD_MODE then
        //OnSetModeCmd()      //let sblib handle it first
        //DTR Deasserted so command mode
        //OnEvent  EVUARTRX       call HandlerUartRxCmd
        //Onevent  EVNOTIFYBUF    call HandlerNotifyBufCmd
        //OnEvent  EVATTRNOTIFY   call HandlerAttrNtfyCmd
        //carCnt=0
        //UartRsp(0)

    elseif cmd==BRIDGE_SPP_MODE then
        //if conns>0 then
        //    OnSetModeSpp()      //let sblib handle it first
            OnEvent  EVUARTRX                call HandlerUartRxSpp
			OnEvent  EVBTC_SPP_DATA_RECEIVED  	call HandlerSppDataBridge
        //    Onevent  EVNOTIFYBUF             call HandlerNotifyBufCmd
        //    OnEvent  EVATTRNOTIFY            call HandlerAttrNtfyCmd
         //   print ok$
        //endif
    endif
endfunc 1
//******************************************************************************

//******************************************************************************
// Equivalent to main() in C
//******************************************************************************

//------------------------------------------------------------------------------
// Enable synchronous event handlers
//------------------------------------------------------------------------------
OnEvent  EVUARTRX					call HandlerUartRxCmd

OnEvent EVINQRESP					call HandlerInqResp
OnEvent	EVBTC_INQUIRY_TIMEOUT		call HandlerBtcInqTimOut	

OnEvent  EVSPPCONN                	call HandlerSppCon
OnEvent  EVBTC_SPP_CONN_TIMEOUT   	call HandlerSppConnTimOut
OnEvent  EVSPPDISCON              	call HandlerSppDiscon
OnEvent  EVBTC_SPP_DATA_RECEIVED  	call HandlerSppData

OnEvent  EVBTC_PAIR_REQUEST       	call HandlerPairReq
OnEvent  EVBTC_PIN_REQUEST        	call HandlerPinReq
OnEvent  EVBTC_PAIR_RESULT        	call HandlerPairRes

OnEvent EVBLE_ADV_REPORT			call HandlerAdvRpt
OnEvent  EVBLE_SCAN_TIMEOUT       	call HandlerBlrScanTimOut
OnEvent  EVBLEMSG                 	call HandlerBleMsg
//OnEvent EvDiscon                    call HndlrDiscon

OnEvent  EVDISCPRIMSVC            	call HandlerPrimSvc
OnEvent  EVDISCCHAR               	call HandlerCharDisc
OnEvent  EVDISCDESC               	call HandlerDescDisc
OnEvent  EVATTRREAD 				call HandlerAttrRead
OnEvent  EVATTRWRITE              	call HandlerAttrWrite
OnEvent  EVATTRNOTIFY             	call HandlerAttrNtfyCmd

OnEvent  EVMSGAPP                 call SetMode

//==============================================================================
//==============================================================================
sub Initialise()
	InitBtDevice()
	InitConnHandles()
	
	print "\n-----------------------\n"
	print " BLUEZ EXPLORER v";mjVersion;".";mnVersion;"\n"
	print "-----------------------\n"
	print "\nType \22help\22 or \22<command> help\22\n"
	
endsub
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
Initialise()

//UartRsp(rc)
print pr$
//------------------------------------------------------------------------------
// Wait for a synchronous event.
// An application can have multiple <WaitEvent> statements
//------------------------------------------------------------------------------
WaitEvent
