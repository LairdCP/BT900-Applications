//******************************************************************************
// Laird Technologies (c) 2014
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++                                                                      ++
// +++++  When UwTerminal downloads the app it will store it as a filenname   ++
// +++++  which consists of all characters up to the first . and excluding it ++
// +++++                                                                      ++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// This library file provides commands to control BT Classic operation and should be
// #included into the file 'cmd.ble.manager.sb' if running on a dual mode module
// e.g. BT900.
//
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Convention : (1) Case sensitive, and commands are presented in alphabetic order
//              (2) If line ends with \ then it continues on next line. That does
//                  not mean that it should be sent as multiple lines
//              (3) Replace anything between ## 
//              (4) #INTaaaa# means a number in decimal, hex, octal or binary
//                      format -> 23 == 0x17 == h'17 == o'23 == b'10111
//                      aaaa is just a description
//              (5) #HEXaaaa# means a string without delimitors consisting of hex 
//                      characters only aaaa is just a description
//              (6) #STRaaaa# means a string without delimitors
//                      aaaa is just a description
//              (7) "STRaaaa" means a string which must have the " delimitor
//                      aaaa is just a description
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//******************************************************************************
// Definitions
//******************************************************************************

        //Set this to 0 to disable all debugging messages
#define ENABLE_DEBUG_PRINTS                  1

        // Number of connections
#define NUM_OF_CONNS                         8

        // size of i[]
#define NUM_OF_I_PARAMS                     (8)

//BLE EVENT MSG IDs
#define BLE_EVBLEMSGID_CONNECT                          0 // msgCtx = connection handle
#define BLE_EVBLEMSGID_DISCONNECT                       1 // msgCtx = connection handle
#define BLE_EVBLEMSGID_IMMEDIATE_ALERT_SERVICE_ALERT    2 // msgCtx = alert level
#define BLE_EVBLEMSGID_LINKLOSS_SERVICE_ALERT           3 // msgCtx = alert level
#define BLE_EVBLEMSGID_SERVICE_ERROR                    4 // msgCtx = resultcode
#define BLE_EVBLEMSGID_HTS_INDICATION_STATE             5 // msgCtx = new indication state 0=off, 1=on
#define BLE_EVBLEMSGID_HTS_INDICATION_CNF               6 // msgCtx = not used
#define BLE_EVBLEMSGID_BPS_INDICATION_STATE             7 // msgCtx = new indication state 0=off, 1=on
#define BLE_EVBLEMSGID_BPS_INDICATION_CNF               8 // msgCtx = not used
#define BLE_EVBLEMSGID_DISPLAY_PASSKEY                  9 // msgCtx = passcode to display
#define BLE_EVBLEMSGID_NEW_BOND                        10 // msgCtx = connection handle
#define BLE_EVBLEMSGID_AUTH_KEY_REQUEST                11 // msgCtx = 1 for passkey, 2 for 16 byte OOB data
#define BLE_EVBLEMSGID_HRS_NOTIFICATION_STATE          12 // msgCtx = new notification state 0=off, 1=on

//#define FUTURE_USE                                   13
#define BLE_EVBLEMSGID_CONN_PARMS_UPDATE               14 // msgCtx = connection handle
#define BLE_EVBLEMSGID_CONN_PARMS_UPDATE_FAIL          15 // msgCtx = connection handle
#define BLE_EVBLEMSGID_CONN_TO_BONDED_MASTER           16 // msgCtx = connection handle
#define BLE_EVBLEMSGID_UPDATED_BOND                    17 // msgCtx = connection handle
#define BLE_EVBLEMSGID_ENCRYPTED                       18 // msgCtx = connection handle
#define BLE_EVBLEMSGID_POWER_FAILURE_WARNING           19 // msgCtx = current supply voltage
#define BLE_EVBLEMSGID_UNENCRYPTED                     20 // msgCtx = connection handle
#define BLE_EVBLEMSGID_DEVICENAME_WRITE                21 // msgCtx = connection handle 

//BLUEZ COMMAND IDs: HCITOOL
#define BLUEZ_COMMAND_HCITOOL_DEV						1
#define BLUEZ_COMMAND_HCITOOL_INQ						2
#define BLUEZ_COMMAND_HCITOOL_SCAN						3
#define BLUEZ_COMMAND_HCITOOL_NAME						5
#define BLUEZ_COMMAND_HCITOOL_INFO						6
#define BLUEZ_COMMAND_HCITOOL_SPINQ						7
#define BLUEZ_COMMAND_HCITOOL_EPINQ						8
#define BLUEZ_COMMAND_HCITOOL_CMD						9
#define BLUEZ_COMMAND_HCITOOL_CON						10
#define BLUEZ_COMMAND_HCITOOL_CC						11
#define BLUEZ_COMMAND_HCITOOL_DC						12
#define BLUEZ_COMMAND_HCITOOL_SR						13
#define BLUEZ_COMMAND_HCITOOL_CPT						14
#define BLUEZ_COMMAND_HCITOOL_RSSI						15
//#define BLUEZ_COMMAND_HCITOOL_SCAN						16
#define BLUEZ_COMMAND_HCITOOL_LQ						17
#define BLUEZ_COMMAND_HCITOOL_TPL						18
#define BLUEZ_COMMAND_HCITOOL_AFH						19
#define BLUEZ_COMMAND_HCITOOL_LP						20
#define BLUEZ_COMMAND_HCITOOL_LST						21
#define BLUEZ_COMMAND_HCITOOL_AUTH						22
#define BLUEZ_COMMAND_HCITOOL_ENC						23
#define BLUEZ_COMMAND_HCITOOL_KEY						24
#define BLUEZ_COMMAND_HCITOOL_CLKOFF					25
#define BLUEZ_COMMAND_HCITOOL_CLOCK						26
#define BLUEZ_COMMAND_HCITOOL_LESCAN					27
#define BLUEZ_COMMAND_HCITOOL_LEWLADD					28
#define BLUEZ_COMMAND_HCITOOL_LEWLRM					29
#define BLUEZ_COMMAND_HCITOOL_LEWLSZ					30
#define BLUEZ_COMMAND_HCITOOL_LEWLCLR					31
#define BLUEZ_COMMAND_HCITOOL_LECC						32
#define BLUEZ_COMMAND_HCITOOL_LEDC						33
#define BLUEZ_COMMAND_HCITOOL_LECUP						34

//BLUEZ COMMAND IDs: GATTTOOL
#define BLUEZ_COMMAND_GATTTOOL_PRIMARY					41
#define BLUEZ_COMMAND_GATTTOOL_CHARACTERISTICS			42
#define BLUEZ_COMMAND_GATTTOOL_CHAR_READ				43
#define BLUEZ_COMMAND_GATTTOOL_CHAR_WRITE				44
#define BLUEZ_COMMAND_GATTTOOL_CHAR_WRITE_REQ			45
#define BLUEZ_COMMAND_GATTTOOL_CHAR_DESC				46
#define BLUEZ_COMMAND_GATTTOOL_LISTEN					47

//******************************************************************************
// Global Variable Declarations
//******************************************************************************
dim rc
dim stRsp$ as string        //Uart rx data is stored here
dim ok$,er$,pr$
dim urtcmd$                 // cmd line from uart
dim tkn$,tlen               // used by command parser
dim urts                    // will be <0 if uart parser suspended
dim i[NUM_OF_I_PARAMS]      // index 0 used for return values
dim hc[NUM_OF_CONNS+1]      // contains connection handles
dim conns                   // number of connections
dim name$					// device name

dim hz						// this is the handle of the current connection (currently used by --primary)
dim gcState                 // gatt client state, 0=IDLE, 1=TableMapping
dim sAttr
dim eAttr

dim prAddr$              	// BT address of last device pairing requested from or initiated with
dim hcSpp                   // handle of connection to use for VSP service

dim command
dim testhndl
//******************************************************************************
// Initialise Global Variable
//******************************************************************************

ok$    = "\nOK"
er$    = "\nERROR "
pr$    = "--------->"

urts = 0					// not suspended
command = 0					// no command being processed

//==============================================================================
//==============================================================================
sub DbgMsg(byval msg$ as string)
  if (ENABLE_DEBUG_PRINTS!=0) then
    print "\n";msg$
  endif
endsub

//==============================================================================
//==============================================================================
sub DbgMsgVal(byval msg$ as string, byval vl as integer)
  if (ENABLE_DEBUG_PRINTS!=0) then
    print "\n";msg$;" ";vl
  endif
endsub

//-------------------------------------------------------------------------
//-------------------------------------------------------------------------
function ExtractIntTokens(u$,stIdx,num)
  while num>0
    tlen = ExtractIntToken(u$,i[stIdx])
    if tlen == 0 then
      exitfunc 4
    endif
    num=num-1
    stIdx = stIdx+1
  endwhile
endfunc 0

//==============================================================================
//==============================================================================
sub ShowConnParms(nCtx as integer)
  dim intrvl,sprvto,slat
  rc= BleGetCurConnParms(nCtx,intrvl,sprvto,slat)
  //AssertResCode(rc,1240)
  if rc==0 then
    DbgMsgVal("Conn Interval",intrvl)
    DbgMsgVal("Conn Supervision Timeout",sprvto)
    DbgMsgVal("Conn Slave Latency",slat)
  endif
endsub
//------------------------------------------------------------------------------
//** #include the correct library file for the smartBASIC module being used 
//------------------------------------------------------------------------------
#include "lib\cmd.bluez.manager.sblib"		//comment out lines above if you are using the bluez commands

//==============================================================================
//==============================================================================
sub UartRsp(rsp as integer)
  //if rsp == 0 then
    print pr$
  //elseif rsp > 0 then 
  //  print er$;integer.h' rsp;pr$
  //endif
  urts = rsp
endsub

//==============================================================================
// Initialise the Bluetooth device
//==============================================================================
sub InitBtDevice()
	
	dim nHandle
	
	name$ = SYSINFO$(4)
	name$ = right$(name$, 6)
	name$ = StrHexize$(name$)
	name$ = "bluez-" + name$
	rc = BTCSETFRIENDLYNAME (name$)			
	
	rc = BtcModeSet(11)							//Connectable, pairable, and general discoverability
													//This should be added to hciconfig later
												

	rc = btcSppOpen(nHandle)
	
endsub											
//==============================================================================
// Print the Help menu
//==============================================================================
function _Help()

	print "\nAvailable Commands: \n"
	print "\n"
	print "	help\n"
	print "	hcitool\n"
	print "	rfcomm\n"
	print "	gatttool\n"
	print "	hciconfig\n"
	print "	quit/exit\n"
	print "\n"
	print "For more information on the usage of each command use:\n"
	print "<command> --help\n\n"

endfunc 1

//==============================================================================
// print the hcitool help menu
//==============================================================================
function _HciHelp()

	print "Usage:\n"
	print "	hcitool [options] <command> [command parameters]\n"
	print "\n"
	print "Commands:\n"
	print "	dev 		Display local devices\n"
	print "	inq 		Inquire remote devices\n"
	print "	scan		Scan for remote devices\n"
//	print "	name		Get name from remote device\n"
//	print "	info		Get information from remote device\n"
//	print "	spinq		Start periodic inquiry\n"
//	print "	epinq		Exit periodic inquiry\n"
//	print "	cmd 		Submit arbitrary HCI commands\n"
	print "	con 		Display active connections\n"
	print "	cc  		Create connection to remote device\n"
	print "	dc  		Disconnect from remote device\n"
//	print "	sr  		Switch master/slave role\n"
//	print "	cpt 		Change connection packet type\n"
//	print "	rssi		Display connection RSSI\n"
//	print "	lq  		Display link quality\n"
//	print "	tpl 		Display transmit power level\n"
//	print "	afh 		Display AFH channel map\n"
//	print "	lp  		Set/display link policy settings\n"
//	print "	lst 		Set/display link supervision timeout\n"
	print "	auth		Request authentication\n"
	print "	enc 		Set connection encryption\n"
	print "	key         Change connection link key\n"
	print "	clkoff      Read clock offset\n"
	print "	clock       Read local or remote clock\n"
	print "	lescan      Start LE scan\n"
//	print "	lewladd     Add device to LE White List\n"
//	print "	lewlrm      Remove device from LE White List\n"
//	print "	lewlsz      Read size of LE White List\n"
//	print "	lewlclr     Clear LE White list\n"
	print "	lecc        Create a LE Connection\n"
	print "	ledc        Disconnect a LE Connection\n"
	print "	lecup       LE Connection Update\n"
	print "\n"
	print "For more information on the usage of each command use:\n"
	print "	hcitool <command> --help\n\n"
	
endfunc 1
//==============================================================================
// Print the gatt help menu
//==============================================================================
function _GattHelp()
//
//Help Options:
//  -h, --help                                Show help options
//  --help-all                                Show all help options
//  --help-gatt                               Show all GATT commands
//  --help-params                             Show all Primary Services/Characteristics arguments
//  --help-char-read-write                    Show all Characteristics Value/Descriptor Read/Write arguments

	print "Usage:\n"
	print "  gatttool [OPTION...]\n"
	print "\n"
	print "GATT commands\n"
	print "	--primary                                 Primary Service Discovery\n"
	print "	--characteristics                         Characteristics Discovery\n"
	print "	--char-read                               Characteristics Value/Descriptor Read\n"
	print "	--char-write                              Characteristics Value Write Without Response (Write Command) \n"
	print "	--char-write-req                          Characteristics Value Write (Write Request)	\n"
	print "	--char-desc                               Characteristics Descriptor Discovery\n"
	print "	--listen                                  Listen for notifications and indications\n"
	print "	-I, --interactive                         Use interactive mode\n"
	print "\n"
	print "Application Options:\n"
	print "	-i, --adapter=hciX                        Specify local adapter interface\n"
	print "	-b, --device=MAC                          Specify remote Bluetooth address\n"
	print "	-t, --addr-type=[public | random]         Set LE address type. Default: public\n"
	print "	-m, --mtu=MTU                             Specify the MTU size\n"
	print "	-p, --psm=PSM                             Specify the PSM for GATT/ATT over BR/EDR\n"
	print "	-l, --sec-level=[low | medium | high]     Set security level. Default: low\n"
	print "	-I, --interactive                         Use interactive mode\n\n"
	
endfunc 1

//==============================================================================
// Print the hciconfig help menu
//==============================================================================
function _HciCfgHelp() as integer
	
	print "Commands:\n"
	print "	up                 	Open and initialize HCI device\n"
	print "	down               	Close HCI device\n"
	print "	reset              	Reset HCI device\n"
	print "	rstat              	Reset statistic counters\n"
	print "	auth               	Enable Authentication\n"
	print "	noauth             	Disable Authentication\n"
	print "	encrypt            	Enable Encryption\n"
	print "	noencrypt          	Disable Encryption\n"
	print "	piscan             	Enable Page and Inquiry scan\n"
	print "	noscan             	Disable scan\n"
	print "	iscan              	Enable Inquiry scan\n"
	print "	pscan              	Enable Page scan\n"
	print "	ptype      [type]  	Get/Set default packet type\n"
	print "	lm         [mode]  	Get/Set default link mode\n"
	print "	lp         [policy]	Get/Set default link policy\n"
	print "	name       [name]  	Get/Set local name\n"
	print "	class      [class] 	Get/Set class of device\n"
	print "	voice      [voice] 	Get/Set voice setting\n"
	print "	iac        [iac]   	Get/Set inquiry access code\n"
	print "	inqtpl     [level] 	Get/Set inquiry transmit power level\n"
	print "	inqmode    [mode]  	Get/Set inquiry mode\n"
	print "	inqdata    [data]  	Get/Set inquiry data\n"
	print "	inqtype    [type]  	Get/Set inquiry scan type\n"
	print "	inqparms   [win:int]	Get/Set inquiry scan window and interval\n"
	print "	pageparms  [win:int]	Get/Set page scan window and interval\n"
	print "	pageto     [to]    	Get/Set page timeout\n"
	print "	afhmode    [mode]  	Get/Set AFH mode\n"
	print "	sspmode    [mode]  	Get/Set Simple Pairing Mode\n"
	print "	aclmtu     <mtu:pkt>	Set ACL MTU and number of packets\n"
	print "	scomtu     <mtu:pkt>	Set SCO MTU and number of packets\n"
	print "	putkey     <bdaddr>	Store link key on the device\n"
	print "	delkey     <bdaddr>	Delete link key from the device\n"
	print "	oobdata            	Display local OOB data\n"
	print "	commands           	Display supported commands\n"
	print "	features           	Display device features\n"
	print "	version            	Display version information\n"
	print "	revision           	Display revision information\n"
	print "	block      <bdaddr>	Add a device to the blacklist\n"
	print "	unblock    <bdaddr>	Remove a device from the blacklist\n"
	print "	lerandaddr <bdaddr>	Set LE Random Address\n"
	print "	leadv              	Enable LE advertising\n"
	print "	noleadv            	Disable LE advertising\n"
	print "	lestates           	Display the supported LE states\n\n"

endfunc 1
//==============================================================================
// Print the rfcomm help menu
//==============================================================================
function _rfcommHelp()

	print " Usage:\n"
	print " rfcomm [options] <command> <dev>\n"
	print "\n Options:\n"
	print " 	-i [hciX|bdaddr]      Local HCI device or BD Address\n"
	print " 	-h, --help            Display help\n"
	print " 	-r, --raw             Switch TTY into raw mode\n"
	print " 	-A, --auth            Enable authentication\n"
	print " 	-E, --encrypt         Enable encryption\n"
	print " 	-S, --secure          Secure connection\n"
	print " 	-M, --master          Become the master of a piconet\n"
	print " 	-f, --config [file]   Specify alternate config file\n"
	print " 	-a                    Show all devices (default)\n"
	print "\n Commands:\n"
	//print " 	bind     <dev> <bdaddr> [channel]	Bind device\n"
	print " 	release  <dev>                   	Release device\n"
	print " 	show     <dev>                   	Show device\n"
	print " 	connect  <bdaddr> 					Connect device\n"
	print " 	listen   <dev> [channel [cmd]]   	Listen\n"
	print " 	watch    <dev> [channel [cmd]]   	Watch\n"
	print " 	write    --handle=0000 -data=abc123 Write\n\n"

endfunc 1
//==============================================================================
//==============================================================================
function AcqConnHandle(hConn)
  dim z
  for z=1 to (NUM_OF_CONNS)
    if hc[z] == -1 then
      hc[z]=hConn
      exitfunc z
    endif
  next
endfunc 0
//==============================================================================
// Extract the hcitool command
//==============================================================================
function _Hci()
	
	tlen = ExtractStrToken(urtcmd$,tkn$)
	if tlen == 0 then
		print "\nInsufficient parameters. For more information use"
		print "\nhcitool help\n"
		exitfunc 5			//Youssif: Here must display message need mroe parameters						//or display the whole help menu
	endif
	//=================================================
	if strcmp(tkn$,"help")==0 then
		rc = _HciHelp()
	endif
	
	if strcmp(tkn$,"dev")==0 then
		rc = _dev()								//Display the address of the local device
	endif
	
	if strcmp(tkn$,"inq")==0 then				
		command = BLUEZ_COMMAND_HCITOOL_INQ
		print "Inquiring...\n"
		rc = _inquiry()							//This function only needs to show the address of remote devices
	endif
	
	if strcmp(tkn$,"scan")==0 then
		print "Scanning...\n"
		command = BLUEZ_COMMAND_HCITOOL_SCAN
		rc = _inquiry()							//This function must show the address and name of remote devices
	endif
	
	if strcmp(tkn$, "cc")==0 then
		rc = _sppConnect()						//This function should connect to an SPP device
	endif
	
	if strcmp(tkn$, "dc")==0 then
		rc = _sppDisconnect()
	endif
	
	if strcmp(tkn$, "auth")== 0 then
		rc = _auth()							//This is the equivalent of pair
	endif
	
	if strcmp(tkn$, "lescan")==0 then
		rc = _leScan()							//This function should show the addresses of Low Energy devices
	endif
	
	if strcmp(tkn$, "lecc")==0 then
		rc = _leConnect()
	endif
	
	if strcmp(tkn$, "ledc")==0 then
		rc = _leDisconnect()
	endif
	
endfunc 1
//==============================================================================
// Extract the gatttool command
//==============================================================================
function _Gatt()
	tlen = ExtractStrToken(urtcmd$,tkn$)
	if tlen == 0 then
		print "\nInsufficient parameters. For more information use"
		print "\ngatttool help\n"
		exitfunc 5		//Youssif: Here must display message need mroe parameters
	endif
	//=================================================
	if strcmp(tkn$,"help")==0 then
		rc = _GattHelp()
	endif

	if strcmp(tkn$,"primary")==0 then
		command = BLUEZ_COMMAND_GATTTOOL_PRIMARY
		rc = _GattPrimary()
	endif	

	if strcmp(tkn$,"characteristics")==0 then
		command = BLUEZ_COMMAND_GATTTOOL_CHARACTERISTICS
		rc = _GattChar()
	endif
	
	if strcmp(tkn$, "char")==0 then 
		strshiftleft(urtcmd$, 1)
		rc = ExtractStrToken(urtcmd$, tkn$)
		if strcmp(tkn$, "read")==0 then
			rc = _GattCharRead()
		elseif strcmp(tkn$, "write")==0 then
			rc = _GattCharWrite()
		endif
	
	endif
	
endfunc 1
//==============================================================================
// Extract the hciconfig command
//==============================================================================
function _HciCfg()
	
	dim s$
	tlen = ExtractStrToken(urtcmd$,tkn$)
	
	if tlen == 0 then
		print "\nInsufficient parameters. For more information use"
		print "\nhciconfig help"
		exitfunc 5		//Youssif: Here must display message need mroe parameters
	endif
	
	if strcmp(tkn$,"help")==0 then
		rc = _HciCfgHelp()
	endif
	
	if strcmp(tkn$,"reset")==0 then
		reset(0)
	endif
	
	if strcmp(tkn$,"auth")==0 then 
		print "Set the device to be pairable\n" 
		rc = BtcModeSet(0x0B)
	endif
	
	if strcmp(tkn$,"name")==0 then 
		tlen = ExtractStrToken(urtcmd$,tkn$)
		if tlen == 0 then
			rc = BtcGetFriendlyName(s$)
			print "\n";s$;"\n"
		else
			rc = BtcSetFriendlyName(tkn$)
		endif
	endif
	
	if strcmp(tkn$,"piscan")==0 then 
		//Enable inquiry scan and page scan (default)
	endif
	
	if strcmp(tkn$,"pscan")==0 then 
		//Enable page scan
	endif
	
	if strcmp(tkn$,"iscan")==0 then 
		//Enable inquiry scan
	endif
	
	if strcmp(tkn$,"noscan")==0 then 
		//The adapter in not detectable by other devices and will not accept any incoming connections
	endif
	
endfunc 1
//==============================================================================
// Extract the rfcomm command
//==============================================================================
function _rfcomm()
	
	tlen = ExtractStrToken(urtcmd$,tkn$)
	if strcmp(tkn$, "help")==0 then
		rc = _rfcommHelp()
		exitfunc 1 
	endif
	
	if strcmp(tkn$, "connect")==0 then
		rc = _rfcommConnect()
	endif
	
	if strcmp(tkn$, "write")==0 then
		rc = _rfcommWrite()
	endif
	
endfunc 1
//==============================================================================
// Extract the received Uart command
//==============================================================================
function OnUartCmd() as integer

	tlen = ExtractStrToken(urtcmd$,tkn$) //get first token
	
	if strcmp(tkn$,"hcitool")==0 then
		rc = _Hci()
      
    elseif strcmp(tkn$,"gatttool")==0 then
		rc = _Gatt()
	  
	elseif strcmp(tkn$,"hciconfig")==0 then
		rc = _HciCfg()
		
	elseif strcmp(tkn$, "rfcomm")==0 then
		rc = _rfcomm()
	  
	elseif strcmp(tkn$, "help")==0 then
		rc = _Help()
	
	elseif strcmp(tkn$,"exit")==0 || strcmp(tkn$,"quit")==0  then
      reset(0)
	
	elseif strcmp(tkn$,"")==0 then
		//exitfunc 1

	else
		print tkn$;": command not found\n"
	endif
	
	// send a response back to the user
	UartRsp(rc)
	
endfunc 1

//******************************************************************************
// Handler definitions
//******************************************************************************

//==============================================================================
// This handler is called when there is an inquiry report waiting to be read 
// Algorithm will prevent display of data from the same peer consecutively 
//==============================================================================
function HandlerInqResp(respType) as integer
	
	dim ad$,dta$,ndx,rsi,tag, name$
	
	rc = BtcInquiryGetReport(ad$,dta$,ndx,rsi)
	print "\n		"; StrHexize$(ad$)
	if command == BLUEZ_COMMAND_HCITOOL_INQ then
		//print "\n"
	elseif command == BLUEZ_COMMAND_HCITOOL_SCAN then
		if respType == 2 then
			//Get local name
			tag = 0x09
			rc=BtcGetEIRbyTag(dta$, tag, name$)
			if rc == 0x5703 then
				tag = 0x08
				rc=BtcGetEIRbyTag(dta$, tag, name$)
			endif
				
			if rc == 0 then
				print "  ";name$
			endif
			
		else
			print "  n/a"
		endif
	endif
	
endfunc 1

//==============================================================================
// Called after an SPP connection attempt
//==============================================================================
function HandlerSppCon(hConn, res) as integer
    dim hz

    //print "\n --- SPP Connect: (";integer.h' res;")"
    //if connected successfully
    print "rfcomm connecting...\n"
	if res == 0 then
		print "rfcomm connected. Connection handle=";hConn;"\n"
	else
		print "rfcomm connection failed: ";res;"\n"
    endif        
endfunc 1

//==============================================================================
// Called when a connection attempt to an SPP device times out
//==============================================================================
function HandlerSppConnTimOut() as integer
    print "\n --- SPP Conn Attempt Timeout"
endfunc 1

//==============================================================================
// Called when an SPP disconnection occurs
//==============================================================================
function HandlerSppDiscon(hConn)
    dim hz
    
    //hz = RelConnHandle(hConn)
    conns = conns - 1
    print "\n --- Spp Disconnect: handle=";hz
endfunc 1
//==============================================================================
// This handler is called when there is an inquiry timeout
//==============================================================================
function HandlerBtcInqTimOut() as integer 
	print "\nInquiry stopped via timeout\n" 
	UartRsp(0)
endfunc 1

//==============================================================================
// Called when data is received via SPP
//==============================================================================
function HandlerSppData()
    dim hPort, data$, rLen
    print "Reached handler Spp Data\n"
    '//read and print data while there is data available to read
    while BtcSppRead(hPort, data$, rLen) == 0    
        if rLen>0 then
            //print"\nPort Handle: ";hPort; " Length: ";rLen;"\nData: ";data$;pr$
			print "rfcomm data: ";data$;"\n"
        endif
    endwhile
endfunc 1
//==============================================================================
// Called when there is a pairing request from another device
//==============================================================================
function HandlerPairReq()
	dim s$
    rc=BtcGetPAIRRequestBDAddr(s$)
    prAddr$ = s$
    print "\nPair Req: "; StrHexize$(s$);" \n"
	rc = BtcSendPAIRResp(1)
endfunc 1

//==============================================================================
// Called on a pin request from another device
//==============================================================================
function HandlerPINReq() 

	dim mac$
    rc=BtcGetPinRequestBDAddr(mac$)
    if rc==0 then
        print "PIN Req: "; StrHexize$(mac$);pr$;"\n"
    else
        //AssertResCode(rc,2273)
		print "Handler PIN Req is a problem\n"
    endif
endfunc 1

//==============================================================================
// Called after a pairing attempt
//==============================================================================
function HandlerPairRes(res)
    //print "Received the pin result\n"
	print "Pair Result: ";res; " "; StrHexize$(prAddr$);"\n"
endfunc 1

//==============================================================================
// This handler is called when there is an inquiry report waiting to be read 
// Algorithm will prevent display of data from the same peer consecutively 
//==============================================================================
function HandlerAdvRpt() as integer
  dim ad$,dta$,ndisc,rsi
  rc = BleScanGetAdvReport(ad$,dta$,ndisc,rsi)
  while rc==0
	ad$ = right$(ad$,8)
    print "\n ";strhexize$(ad$)
	//;" ";strhexize$(dta$);" ";ndisc;" ";rsi
    rc = BleScanGetAdvReport(ad$,dta$,ndisc,rsi)
  endwhile
endfunc 1
//==============================================================================
// This handler is called when there is a Ble scan timeout
//==============================================================================
function HandlerBlrScanTimOut() as integer 
	print "\nScanning stopped via timeout\n"
	UartRsp(0)
endfunc 1
//==============================================================================
// This handler is called when there is a BLE message
//==============================================================================
function HandlerBleMsg(BYVAL nMsgId AS INTEGER, BYVAL nCtx AS INTEGER) as integer
  //dim hz
  
  select nMsgId
  case BLE_EVBLEMSGID_CONNECT
    //hz = AcqConnHandle(nCtx)
    hz = nCtx
	//conns = conns + 1
    print "\nConnected\n" 
	//(";integer.h' nCtx;") handle=";hz
    if hz == 0 then
      //Could not store the handle so drop the connection
      rc = BleDisconnect(nCtx)
      print " DROPPED"
    else
      //accepted so display connection parameters
      //ShowConnParms(nCtx)
      //always assume most recent connection for VSP
      //hcVsp = hc[hz]
    endif
    
  case BLE_EVBLEMSGID_DISCONNECT
    //hz = RelConnHandle(nCtx)
    conns = conns - 1
    print "\n --- Disconnect: (";integer.h' nCtx;") handle=";hz;pr$

  case BLE_EVBLEMSGID_DISPLAY_PASSKEY
    DbgMsgVal("Display Pairing Passkey ",nCtx)

  case BLE_EVBLEMSGID_NEW_BOND
    DbgMsg(" +++ New Bond")

  case BLE_EVBLEMSGID_UPDATED_BOND
    DbgMsg(" +++ Updated Bond")

  case BLE_EVBLEMSGID_ENCRYPTED
    DbgMsg(" +++ Encrypted Connection")

  case BLE_EVBLEMSGID_CONN_TO_BONDED_MASTER
    DbgMsgVal(" -- Conn to Bonded Master ",nCtx)

  case BLE_EVBLEMSGID_AUTH_KEY_REQUEST
    DbgMsgVal(" +++ Auth Key Request, type=",nCtx)

  case BLE_EVBLEMSGID_CONN_PARMS_UPDATE
    //ShowConnParms(nCtx)

  case BLE_EVBLEMSGID_CONN_PARMS_UPDATE_FAIL
    DbgMsg(" ??? Conn Parm Negotiation FAILED")

  case else
    DbgMsgVal("Unknown Ble Msg", nMsgId)
  endselect
endfunc 1
//==============================================================================
// This handler is called when a BLE device disconnects
//==============================================================================
function HndlrDiscon(nCtx,nRsn) as integer
	print "Disconnected\n"
endfunc 1 

//==============================================================================
// This handler is called when a BLE primary service is discovered
//==============================================================================
function HandlerPrimSvc(hConn,hUuid,hStart,hEnd) as integer
  //select gcState
 // case 0
	sAttr = hStart
	eAttr = hEnd
	if command == BLUEZ_COMMAND_GATTTOOL_PRIMARY then
		print "\n" 
		print "attr handle = 0x";integer.h' hStart
		print ", end grp handle = 0x";integer.h' hEnd
		print ", uuid = ";integer.h' hUuid
		rc = BleDiscServiceNext(hz)
		if rc != 0 then 
			print "\n"
			BleGattcClose()
			exitfunc 1 
		endif
	
	elseif command == BLUEZ_COMMAND_GATTTOOL_CHARACTERISTICS then
		rc = BleDiscCharFirst(hz,0,sAttr,eAttr)
	
	endif
	
	
endfunc 1

//==============================================================================
// This handler is called when a BLE characteristic is discovered
//==============================================================================
function HandlerCharDisc(hConn,hUuid,cProp,hVal,hiUuid) as integer

	if hUuid != 0 then
		print "\n"
		print "handle = 0x";integer.h' hVal-1
		print ", char properties = 0x";integer.h' cProp
		print ", char value handle = 0x";integer.h' hVal
		print ", uuid = ";integer.h' hUuid
	endif
	
	rc = BleDiscCharNext(hz)
	if rc != 0 then
		rc = BleDiscServiceNext(hz)
			if rc !=0 then
				BleGattcClose()
			endif
		exitfunc 1
	endif
	
endfunc 1
//==============================================================================
// This handler is called when a BLE characteristic attribute has been read
//==============================================================================
function HandlerAttrRead(hConn,hAttr,nSts) as integer

	dim a$,ofst  
	if nSts == 0 then
		rc = BleGattcReadData(hConn,testhndl,ofst,a$)
		if rc==0 then
			print "Characteristic value/descriptor: "
			print "";StrHexize$(a$)
			print " (";StrEscape$(a$);") \n"
			print "\n"
		else	
			print "At handleAttrRea,d rc returns ";rc;"\n"
		endif
	
	else 
		print "nSts is not 0 \n"									//Must print correct error message here
	endif  
	BleGattcClose()
	
endfunc 1
//==============================================================================
// This handler is called when a BLE characteristic attribute has been written to 
//==============================================================================
function HandlerAttrWrite(hConn,aHndl,nSts) as integer
    
	if nSts == 0 then
		print "Characteristic value was written successfully\n"
	else 
		print "Characteristic Write failed: Attribute Can't be written\n"		//Different error messages should be printed for different nSts
	endif
	
	//"Characteristic value was written successfully" should be printed if sec level must be increased
endfunc 1
//==============================================================================
// This handler is called when there is data notified or indicated
//==============================================================================
function HandlerAttrNtfyCmd() as integer
  dim hConn,hAttr,att$,dscd
  print "\nEVATTRNOTIFY()"
  do
    rc=BleGattcNotifyRead(hConn,hAttr,att$,dscd)
    if rc==0 then
      print "\n >BleGattcNotifyRead("
      print "hConn=";integer.h' hConn;",handle=";hAttr;",Dumped=";dscd
      print ",data=";StrHexize$(att$);")"
    endif
  dowhile rc==0
endfunc 1
//==============================================================================
//==============================================================================

//==============================================================================
// This handler is called when data has arrived at the serial port
//==============================================================================
function HandlerUartRxCmd() as integer
	dim nMatch
	
	
	//Youssif: why is the 13 used?
	nMatch=UartReadMatch(stRsp$,13)
	if nMatch!=0 then
		//CR exists in the input buffer
		urtcmd$ = strsplitleft$(stRsp$, nMatch)
		exitfunc OnUartCmd()
	endif
endfunc 1

//******************************************************************************

//******************************************************************************
// Equivalent to main() in C
//******************************************************************************

//------------------------------------------------------------------------------
// Enable synchronous event handlers
//------------------------------------------------------------------------------
OnEvent  EVUARTRX					call HandlerUartRxCmd

OnEvent EVINQRESP					call HandlerInqResp
OnEvent	EVBTC_INQUIRY_TIMEOUT		call HandlerBtcInqTimOut	

OnEvent  EVSPPCONN                	call HandlerSppCon
OnEvent  EVBTC_SPP_CONN_TIMEOUT   	call HandlerSppConnTimOut
OnEvent  EVSPPDISCON              	call HandlerSppDiscon
OnEvent  EVBTC_SPP_DATA_RECEIVED  	call HandlerSppData

OnEvent  EVBTC_PAIR_REQUEST       	call HandlerPairReq
OnEvent  EVBTC_PIN_REQUEST        	call HandlerPinReq
OnEvent  EVBTC_PAIR_RESULT        	call HandlerPairRes

OnEvent EVBLE_ADV_REPORT			call HandlerAdvRpt
OnEvent  EVBLE_SCAN_TIMEOUT       	call HandlerBlrScanTimOut
OnEvent  EVBLEMSG                 	call HandlerBleMsg
OnEvent EvDiscon                  	call HndlrDiscon

OnEvent  EVDISCPRIMSVC            	call HandlerPrimSvc
OnEvent  EVDISCCHAR               	call HandlerCharDisc
OnEvent EVATTRREAD 					call HandlerAttrRead
OnEvent  EVATTRWRITE              	call HandlerAttrWrite
OnEvent  EVATTRNOTIFY             	call HandlerAttrNtfyCmd

//OnEvent 
//==============================================================================
//==============================================================================
sub Initialise()
	InitBtDevice()
	print "\n-----------------------\n"
	print " BLUEZ EXPLORER v0.4\n"
	print "-----------------------\n"
	print "\nType \22help\22 or \22<command> help\22\n"
	
endsub

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
Initialise()

UartRsp(rc)
//------------------------------------------------------------------------------
// Wait for a synchronous event.
// An application can have multiple <WaitEvent> statements
//------------------------------------------------------------------------------
WaitEvent