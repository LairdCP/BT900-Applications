//******************************************************************************
// Laird Technologies (c) 2014
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++                                                                      ++
// +++++  When UwTerminal downloads the app it will store it as a filenname   ++
// +++++  which consists of all characters up to the first . and excluding it ++
// +++++                                                                      ++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// This library file provides commands to control BT Classic operation and should be
// #included into the file 'cmd.ble.manager.sb' if running on a dual mode module
// e.g. BT900.
//
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Convention : (1) Case sensitive, and commands are presented in alphabetic order
//              (2) If line ends with \ then it continues on next line. That does
//                  not mean that it should be sent as multiple lines
//              (3) Replace anything between ## 
//              (4) #INTaaaa# means a number in decimal, hex, octal or binary
//                      format -> 23 == 0x17 == h'17 == o'23 == b'10111
//                      aaaa is just a description
//              (5) #HEXaaaa# means a string without delimitors consisting of hex 
//                      characters only aaaa is just a description
//              (6) #STRaaaa# means a string without delimitors
//                      aaaa is just a description
//              (7) "STRaaaa" means a string which must have the " delimitor
//                      aaaa is just a description
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//******************************************************************************
// Definitions
//******************************************************************************

        //Set this to 0 to disable all debugging messages
#define ENABLE_DEBUG_PRINTS                  1

        // Number of connections
#define NUM_OF_CONNS                         8

        // size of i[]
#define NUM_OF_I_PARAMS                     (8)

//BLE EVENT MSG IDs
#define BLE_EVBLEMSGID_CONNECT                          0 // msgCtx = connection handle
#define BLE_EVBLEMSGID_DISCONNECT                       1 // msgCtx = connection handle
#define BLE_EVBLEMSGID_IMMEDIATE_ALERT_SERVICE_ALERT    2 // msgCtx = alert level
#define BLE_EVBLEMSGID_LINKLOSS_SERVICE_ALERT           3 // msgCtx = alert level
#define BLE_EVBLEMSGID_SERVICE_ERROR                    4 // msgCtx = resultcode
#define BLE_EVBLEMSGID_HTS_INDICATION_STATE             5 // msgCtx = new indication state 0=off, 1=on
#define BLE_EVBLEMSGID_HTS_INDICATION_CNF               6 // msgCtx = not used
#define BLE_EVBLEMSGID_BPS_INDICATION_STATE             7 // msgCtx = new indication state 0=off, 1=on
#define BLE_EVBLEMSGID_BPS_INDICATION_CNF               8 // msgCtx = not used
#define BLE_EVBLEMSGID_DISPLAY_PASSKEY                  9 // msgCtx = passcode to display
#define BLE_EVBLEMSGID_NEW_BOND                        10 // msgCtx = connection handle
#define BLE_EVBLEMSGID_AUTH_KEY_REQUEST                11 // msgCtx = 1 for passkey, 2 for 16 byte OOB data
#define BLE_EVBLEMSGID_HRS_NOTIFICATION_STATE          12 // msgCtx = new notification state 0=off, 1=on

//#define FUTURE_USE                                   13
#define BLE_EVBLEMSGID_CONN_PARMS_UPDATE               14 // msgCtx = connection handle
#define BLE_EVBLEMSGID_CONN_PARMS_UPDATE_FAIL          15 // msgCtx = connection handle
#define BLE_EVBLEMSGID_CONN_TO_BONDED_MASTER           16 // msgCtx = connection handle
#define BLE_EVBLEMSGID_UPDATED_BOND                    17 // msgCtx = connection handle
#define BLE_EVBLEMSGID_ENCRYPTED                       18 // msgCtx = connection handle
#define BLE_EVBLEMSGID_POWER_FAILURE_WARNING           19 // msgCtx = current supply voltage
#define BLE_EVBLEMSGID_UNENCRYPTED                     20 // msgCtx = connection handle
#define BLE_EVBLEMSGID_DEVICENAME_WRITE                21 // msgCtx = connection handle 

//BLUEZ COMMAND IDs: HCITOOL
#define BLUEZ_COMMAND_HCITOOL_DEV						1
#define BLUEZ_COMMAND_HCITOOL_INQ						2
#define BLUEZ_COMMAND_HCITOOL_SCAN						3
#define BLUEZ_COMMAND_HCITOOL_NAME						5
#define BLUEZ_COMMAND_HCITOOL_INFO						6
#define BLUEZ_COMMAND_HCITOOL_SPINQ						7
#define BLUEZ_COMMAND_HCITOOL_EPINQ						8
#define BLUEZ_COMMAND_HCITOOL_CMD						9
#define BLUEZ_COMMAND_HCITOOL_CON						10
#define BLUEZ_COMMAND_HCITOOL_CC						11
#define BLUEZ_COMMAND_HCITOOL_DC						12
#define BLUEZ_COMMAND_HCITOOL_SR						13
#define BLUEZ_COMMAND_HCITOOL_CPT						14
#define BLUEZ_COMMAND_HCITOOL_RSSI						15
//#define BLUEZ_COMMAND_HCITOOL_SCAN						16
#define BLUEZ_COMMAND_HCITOOL_LQ						17
#define BLUEZ_COMMAND_HCITOOL_TPL						18
#define BLUEZ_COMMAND_HCITOOL_AFH						19
#define BLUEZ_COMMAND_HCITOOL_LP						20
#define BLUEZ_COMMAND_HCITOOL_LST						21
#define BLUEZ_COMMAND_HCITOOL_AUTH						22
#define BLUEZ_COMMAND_HCITOOL_ENC						23
#define BLUEZ_COMMAND_HCITOOL_KEY						24
#define BLUEZ_COMMAND_HCITOOL_CLKOFF					25
#define BLUEZ_COMMAND_HCITOOL_CLOCK						26
#define BLUEZ_COMMAND_HCITOOL_LESCAN					27
#define BLUEZ_COMMAND_HCITOOL_LEWLADD					28
#define BLUEZ_COMMAND_HCITOOL_LEWLRM					29
#define BLUEZ_COMMAND_HCITOOL_LEWLSZ					30
#define BLUEZ_COMMAND_HCITOOL_LEWLCLR					31
#define BLUEZ_COMMAND_HCITOOL_LECC						32
#define BLUEZ_COMMAND_HCITOOL_LEDC						33
#define BLUEZ_COMMAND_HCITOOL_LECUP						34

//BLUEZ COMMAND IDs: GATTTOOL
#define BLUEZ_COMMAND_GATTTOOL_PRIMARY					41
#define BLUEZ_COMMAND_GATTTOOL_CHARACTERISTICS			42
#define BLUEZ_COMMAND_GATTTOOL_CHAR_READ				43
#define BLUEZ_COMMAND_GATTTOOL_CHAR_WRITE				44
#define BLUEZ_COMMAND_GATTTOOL_CHAR_WRITE_REQ			45
#define BLUEZ_COMMAND_GATTTOOL_CHAR_DESC				46
#define BLUEZ_COMMAND_GATTTOOL_LISTEN					47

//******************************************************************************
// Global Variable Declarations
//******************************************************************************
dim rc
dim stRsp$ as string        //Uart rx data is stored here
dim ok$,er$,pr$
dim urtcmd$                 // cmd line from uart
dim tkn$,tlen               // used by command parser
dim urts                    // will be <0 if uart parser suspended
dim i[NUM_OF_I_PARAMS]      // index 0 used for return values
dim hc[NUM_OF_CONNS+1]      // contains connection handles
dim conns                   // number of connections
dim name$					// device name

dim hz						// this is the handle of the current connection (currently used by --primary)
dim gcState                 // gatt client state, 0=IDLE, 1=TableMapping
dim sAttr
dim eAttr

dim prAddr$              	// BT address of last device pairing requested from or initiated with
dim hcSpp                   // handle of connection to use for VSP service

dim command
//******************************************************************************
// Initialise Global Variable
//******************************************************************************

ok$    = "\nOK"
er$    = "\nERROR "
pr$    = "\r\n>"

urts = 0					// not suspended
command = 0					// no command being processed

//==============================================================================
//==============================================================================
sub DbgMsg(byval msg$ as string)
  if (ENABLE_DEBUG_PRINTS!=0) then
    print "\n";msg$
  endif
endsub

//==============================================================================
//==============================================================================
sub DbgMsgVal(byval msg$ as string, byval vl as integer)
  if (ENABLE_DEBUG_PRINTS!=0) then
    print "\n";msg$;" ";vl
  endif
endsub

//-------------------------------------------------------------------------
//-------------------------------------------------------------------------
function ExtractIntTokens(u$,stIdx,num)
  while num>0
    tlen = ExtractIntToken(u$,i[stIdx])
    if tlen == 0 then
      exitfunc 4
    endif
    num=num-1
    stIdx = stIdx+1
  endwhile
endfunc 0

//==============================================================================
//==============================================================================
sub ShowConnParms(nCtx as integer)
  dim intrvl,sprvto,slat
  rc= BleGetCurConnParms(nCtx,intrvl,sprvto,slat)
  //AssertResCode(rc,1240)
  if rc==0 then
    DbgMsgVal("Conn Interval",intrvl)
    DbgMsgVal("Conn Supervision Timeout",sprvto)
    DbgMsgVal("Conn Slave Latency",slat)
  endif
endsub
//------------------------------------------------------------------------------
//** #include the correct library file for the smartBASIC module being used 
//------------------------------------------------------------------------------
#include "lib\cmd.bluez.manager.sblib"		//comment out lines above if you are using the bluez commands

//==============================================================================
//==============================================================================
sub UartRsp(rsp as integer)
  //if rsp == 0 then
    print pr$
  //elseif rsp > 0 then 
  //  print er$;integer.h' rsp;pr$
  //endif
  urts = rsp
endsub

//==============================================================================
//==============================================================================
sub InitBtDevice()
	
	dim nHandle
	
	name$ = SYSINFO$(4)
	name$ = right$(name$, 6)
	name$ = StrHexize$(name$)
	name$ = "bluez-" + name$
	rc = BTCSETFRIENDLYNAME (name$)			
	
	rc = BtcModeSet(9)							//Connectable and general discoverability
												//This should be altered from hciconfig later

	rc = btcSppOpen(nHandle)
	
endsub											
//==============================================================================
//==============================================================================
function _Help()

	print "\nAvailable Commands: \n"
	print "\n"
	print "		help\n"
	print "		hcitool\n"
	print "		gatttool\n"
	print "		hciconfig\n"
	print "		quit/exit\n"
	print "\n"
	print "For more information on the usage of each command use:\n"
	print "<command> --help\n"

endfunc 1

//==============================================================================
//==============================================================================
function _HciHelp()

	print "\nUsage:\n"
	print "	hcitool [options] <command> [command parameters]\n"
	print "\n"
	print "Commands:\n"
	print "	dev 		Display local devices\n"
	print "	inq 		Inquire remote devices\n"
//	print "	scan		Scan for remote devices\n"
//	print "	name		Get name from remote device\n"
//	print "	info		Get information from remote device\n"
//	print "	spinq		Start periodic inquiry\n"
//	print "	epinq		Exit periodic inquiry\n"
//	print "	cmd 		Submit arbitrary HCI commands\n"
	print "	con 		Display active connections\n"
	print "	cc  		Create connection to remote device\n"
	print "	dc  		Disconnect from remote device\n"
//	print "	sr  		Switch master/slave role\n"
//	print "	cpt 		Change connection packet type\n"
//	print "	rssi		Display connection RSSI\n"
//	print "	lq  		Display link quality\n"
//	print "	tpl 		Display transmit power level\n"
//	print "	afh 		Display AFH channel map\n"
//	print "	lp  		Set/display link policy settings\n"
//	print "	lst 		Set/display link supervision timeout\n"
	print "	auth		Request authentication\n"
	print "	enc 		Set connection encryption\n"
	print "	key         Change connection link key\n"
	print "	clkoff      Read clock offset\n"
	print "	clock       Read local or remote clock\n"
	print "	lescan      Start LE scan\n"
//	print "	lewladd     Add device to LE White List\n"
//	print "	lewlrm      Remove device from LE White List\n"
//	print "	lewlsz      Read size of LE White List\n"
//	print "	lewlclr     Clear LE White list\n"
	print "	lecc        Create a LE Connection\n"
	print "	ledc        Disconnect a LE Connection\n"
	print "	lecup       LE Connection Update\n"
	print "\n"
	print "For more information on the usage of each command use:\n"
	print "	hcitool <command> --help\n"
	print "\n"
	
endfunc 1
//==============================================================================
//==============================================================================
function _GattHelp()
//
//Help Options:
//  -h, --help                                Show help options
//  --help-all                                Show all help options
//  --help-gatt                               Show all GATT commands
//  --help-params                             Show all Primary Services/Characteristics arguments
//  --help-char-read-write                    Show all Characteristics Value/Descriptor Read/Write arguments

	print "\nUsage:\n"
	print "  gatttool [OPTION...]\n"
	print "\n"
	print "GATT commands\n"
	print "	--primary                                 Primary Service Discovery\n"
	print "	--characteristics                         Characteristics Discovery\n"
	print "	--char-read                               Characteristics Value/Descriptor Read\n"
	print "	--char-write                              Characteristics Value Write Without Response (Write Command) \n"
	print "	--char-write-req                          Characteristics Value Write (Write Request)	\n"
	print "	--char-desc                               Characteristics Descriptor Discovery\n"
	print "	--listen                                  Listen for notifications and indications\n"
	print "	-I, --interactive                         Use interactive mode\n"
	print "\n"
	print "Application Options:\n"
	print "	-i, --adapter=hciX                        Specify local adapter interface\n"
	print "	-b, --device=MAC                          Specify remote Bluetooth address\n"
	print "	-t, --addr-type=[public | random]         Set LE address type. Default: public\n"
	print "	-m, --mtu=MTU                             Specify the MTU size\n"
	print "	-p, --psm=PSM                             Specify the PSM for GATT/ATT over BR/EDR\n"
	print "	-l, --sec-level=[low | medium | high]     Set security level. Default: low\n"
	print "	-I, --interactive                         Use interactive mode"
	print "\n"
	
endfunc 1

//==============================================================================
//==============================================================================
function _HciCfgHelp() as integer
	
	print "Commands:\n"
	print "	up                 	Open and initialize HCI device\n"
	print "	down               	Close HCI device\n"
	print "	reset              	Reset HCI device\n"
	print "	rstat              	Reset statistic counters\n"
	print "	auth               	Enable Authentication\n"
	print "	noauth             	Disable Authentication\n"
	print "	encrypt            	Enable Encryption\n"
	print "	noencrypt          	Disable Encryption\n"
	print "	piscan             	Enable Page and Inquiry scan\n"
	print "	noscan             	Disable scan\n"
	print "	iscan              	Enable Inquiry scan\n"
	print "	pscan              	Enable Page scan\n"
	print "	ptype      [type]  	Get/Set default packet type\n"
	print "	lm         [mode]  	Get/Set default link mode\n"
	print "	lp         [policy]	Get/Set default link policy\n"
	print "	name       [name]  	Get/Set local name\n"
	print "	class      [class] 	Get/Set class of device\n"
	print "	voice      [voice] 	Get/Set voice setting\n"
	print "	iac        [iac]   	Get/Set inquiry access code\n"
	print "	inqtpl     [level] 	Get/Set inquiry transmit power level\n"
	print "	inqmode    [mode]  	Get/Set inquiry mode\n"
	print "	inqdata    [data]  	Get/Set inquiry data\n"
	print "	inqtype    [type]  	Get/Set inquiry scan type\n"
	print "	inqparms   [win:int]	Get/Set inquiry scan window and interval\n"
	print "	pageparms  [win:int]	Get/Set page scan window and interval\n"
	print "	pageto     [to]    	Get/Set page timeout\n"
	print "	afhmode    [mode]  	Get/Set AFH mode\n"
	print "	sspmode    [mode]  	Get/Set Simple Pairing Mode\n"
	print "	aclmtu     <mtu:pkt>	Set ACL MTU and number of packets\n"
	print "	scomtu     <mtu:pkt>	Set SCO MTU and number of packets\n"
	print "	putkey     <bdaddr>	Store link key on the device\n"
	print "	delkey     <bdaddr>	Delete link key from the device\n"
	print "	oobdata            	Display local OOB data\n"
	print "	commands           	Display supported commands\n"
	print "	features           	Display device features\n"
	print "	version            	Display version information\n"
	print "	revision           	Display revision information\n"
	print "	block      <bdaddr>	Add a device to the blacklist\n"
	print "	unblock    <bdaddr>	Remove a device from the blacklist\n"
	print "	lerandaddr <bdaddr>	Set LE Random Address\n"
	print "	leadv              	Enable LE advertising\n"
	print "	noleadv            	Disable LE advertising\n"
	print "	lestates           	Display the supported LE states\n"

endfunc 1
//==============================================================================
//==============================================================================
function AcqConnHandle(hConn)
  dim z
  for z=1 to (NUM_OF_CONNS)
    if hc[z] == -1 then
      hc[z]=hConn
      exitfunc z
    endif
  next
endfunc 0
//==============================================================================
//==============================================================================
function _Hci()
	
	tlen = ExtractStrToken(urtcmd$,tkn$)
	if tlen == 0 THEN
		print "\nInsufficient parameters. For more information use"
		print "\nhcitool help\n"
		exitfunc 5			//Youssif: Here must display message need mroe parameters						//or display the whole help menu
	endif
	//=================================================
	if strcmp(tkn$,"help")==0 then
		rc = _HciHelp()
	endif
	
	if strcmp(tkn$,"dev")==0 then
		rc = _dev()								//Display the address of the local device
	endif
	
	if strcmp(tkn$,"inq")==0 then				
		rc = _inquiry()							//This function only needs to show the address of remote devices
	endif
	
	//if strcmp(tkn$,"scan")==0 then
	//	rc = _BtcScan()							//This function must show the address and name of remote devices
	//endif
	
	if strcmp(tkn$, "cc")==0 then
		rc = _sppConnect()						//This function should connect to an SPP device
	endif
	
	if strcmp(tkn$, "dc")==0 then
		rc = _sppDisconnect()
	endif
	
	if strcmp(tkn$, "auth")== 0 then
		rc = _auth()							//This is the equivalent of pair
	endif
	
	if strcmp(tkn$, "lescan")==0 then
		rc = _leScan()							//This function should show the addresses of Low Energy devices
	endif
	
	if strcmp(tkn$, "lecc")==0 then
		rc = _leConnect()
	endif
	
	if strcmp(tkn$, "ledc")==0 then
		rc = _leDisconnect()
	endif
	
endfunc 1
//==============================================================================
//==============================================================================
function _Gatt()
	tlen = ExtractStrToken(urtcmd$,tkn$)
	if tlen == 0 THEN
		print "\nInsufficient parameters. For more information use"
		print "\ngatttool help\n"
		exitfunc 5		//Youssif: Here must display message need mroe parameters
	endif
	//=================================================
	if strcmp(tkn$,"help")==0 then
		rc = _GattHelp()
	endif

	if strcmp(tkn$,"primary")==0 then
		command = BLUEZ_COMMAND_GATTTOOL_PRIMARY
		rc = _GattPrimary()
	endif	

	if strcmp(tkn$,"characteristics")==0 then
		command = BLUEZ_COMMAND_GATTTOOL_CHARACTERISTICS
		rc = _GattChar()
	endif
endfunc 1
//==============================================================================
//==============================================================================
function _HciCfg()
	tlen = ExtractStrToken(urtcmd$,tkn$)
	
	if tlen == 0 THEN
		print "\nInsufficient parameters. For more information use"
		print "\nhciconfig help"
		exitfunc 5		//Youssif: Here must display message need mroe parameters
	endif
	
	if strcmp(tkn$,"help")==0 then
		rc = _HciCfgHelp()
	endif
	
	if strcmp(tkn$,"auth")==0 then 
		print "Set the device to be pairable\n" 
		rc = BtcModeSet(0x0B)
	endif
	
endfunc 1
//==============================================================================
//==============================================================================
function OnUartCmd() as integer

	tlen = ExtractStrToken(urtcmd$,tkn$) //get first token
	
	if strcmp(tkn$,"hcitool")==0 then
		rc = _Hci()
      
    elseif strcmp(tkn$,"gatttool")==0 then
		rc = _Gatt()
	  
	elseif strcmp(tkn$,"hciconfig")==0 then
		rc = _HciCfg()
	  
	elseif strcmp(tkn$, "help")==0 then
		rc = _Help()
	
	elseif strcmp(tkn$,"exit")==0 || strcmp(tkn$,"quit")==0  then
      reset(0)
	
	elseif strcmp(tkn$,"")==0 then
		//exitfunc 1

	else
		print tkn$;": command not found\n"
	endif
	
	// send a response back to the user
	UartRsp(rc)
endfunc 1

//******************************************************************************
// Handler definitions
//******************************************************************************

//==============================================================================
// This handler is called when there is an inquiry report waiting to be read 
// Algorithm will prevent display of data from the same peer consecutively 
//==============================================================================
function HandlerInqResp(respType) as integer
	dim ad$,dta$,ndx,rsi,tag
	rc = BtcInquiryGetReport(ad$,dta$,ndx,rsi)
	print "\n "; StrHexize$(ad$)
	
endfunc 1

//==============================================================================
// Called after an SPP connection attempt
//==============================================================================
function HandlerSppCon(hConn, res) as integer
    dim hz

    print "\n --- SPP Connect: (";integer.h' res;")"
    //if connected successfully
    if res == 0 then
        //try and acquire a connection handle
        hz = AcqConnHandle(hConn)
        
        //disconnect if failed
        if hz==0 then
            rc=BtcSppDisconnect(hConn)
            print " DROPPED"
        else
            hcSpp = hc[hz]     //always assume most recent connection for SPP
            conns = conns + 1
            print " handle = ";hz;pr$
        endif
    endif        
endfunc 1

//==============================================================================
// Called when a connection attempt to an SPP device times out
//==============================================================================
function HandlerSppConnTimOut() as integer
    print "\n --- SPP Conn Attempt Timeout"
endfunc 1

//==============================================================================
// Called when an SPP disconnection occurs
//==============================================================================
function HandlerSppDiscon(hConn)
    dim hz
    
    //hz = RelConnHandle(hConn)
    conns = conns - 1
    print "\n --- Spp Disconnect: handle=";hz
endfunc 1
//==============================================================================
// This handler is called when there is an inquiry timeout
//==============================================================================
function HandlerBtcInqTimOut() as integer 
	print "\nInquiry stopped via timeout" 
	UartRsp(0)
endfunc 1

//==============================================================================
// Called when data is received via SPP
//==============================================================================
function HandlerSppData()
    dim hPort, data$, rLen
    
    '//read and print data while there is data available to read
    while BtcSppRead(hPort, data$, rLen) == 0    
        if rLen>0 then
            print"\nPort Handle: ";hPort; " Length: ";rLen;"\nData: ";data$;pr$
        endif
    endwhile
endfunc 1
//==============================================================================
// Called when there is a pairing request from another device
//==============================================================================
function HandlerPairReq()
	dim s$
    rc=BtcGetPAIRRequestBDAddr(s$)
    prAddr$ = s$
    print "\nPair Req: "; StrHexize$(s$);pr$
	rc = BtcSendPAIRResp(1)
endfunc 1

//==============================================================================
// Called on a pin request from another device
//==============================================================================
function HandlerPINReq() 

	dim mac$
    rc=BtcGetPinRequestBDAddr(mac$)
    if rc==0 then
        print "\nPIN Req: "; StrHexize$(mac$);pr$
    else
        //AssertResCode(rc,2273)
		print "Handler PIN Req is a problem\n"
    endif
endfunc 1

//==============================================================================
// Called after a pairing attempt
//==============================================================================
function HandlerPairRes(res)
    //print "Received the pin result\n"
	print "\nPair Result: ";res; " "; StrHexize$(prAddr$);pr$
endfunc 1

//==============================================================================
// This handler is called when there is an inquiry report waiting to be read 
// Algorithm will prevent display of data from the same peer consecutively 
//==============================================================================
function HandlerAdvRpt() as integer
  dim ad$,dta$,ndisc,rsi
  rc = BleScanGetAdvReport(ad$,dta$,ndisc,rsi)
  while rc==0
	ad$ = right$(ad$,8)
    print "\n ";strhexize$(ad$)
	//;" ";strhexize$(dta$);" ";ndisc;" ";rsi
    rc = BleScanGetAdvReport(ad$,dta$,ndisc,rsi)
  endwhile
endfunc 1
//==============================================================================
// This handler is called when there is a Ble scan timeout
//==============================================================================
function HandlerBlrScanTimOut() as integer 
	print "\nScanning stopped via timeout"
	UartRsp(0)
endfunc 1
//==============================================================================
// This handler is called when there is a BLE message
//==============================================================================
function HandlerBleMsg(BYVAL nMsgId AS INTEGER, BYVAL nCtx AS INTEGER) as integer
  //dim hz
  
  select nMsgId
  case BLE_EVBLEMSGID_CONNECT
    //hz = AcqConnHandle(nCtx)
    hz = nCtx
	//conns = conns + 1
    print "\n --- Connect: (";integer.h' nCtx;") handle=";hz
    if hz == 0 then
      //Could not store the handle so drop the connection
      rc = BleDisconnect(nCtx)
      print " DROPPED"
    else
      //accepted so display connection parameters
      //ShowConnParms(nCtx)
      //always assume most recent connection for VSP
      //hcVsp = hc[hz]
    endif
    
  case BLE_EVBLEMSGID_DISCONNECT
    //hz = RelConnHandle(nCtx)
    conns = conns - 1
    print "\n --- Disconnect: (";integer.h' nCtx;") handle=";hz;pr$

  case BLE_EVBLEMSGID_DISPLAY_PASSKEY
    DbgMsgVal("Display Pairing Passkey ",nCtx)

  case BLE_EVBLEMSGID_NEW_BOND
    DbgMsg(" +++ New Bond")

  case BLE_EVBLEMSGID_UPDATED_BOND
    DbgMsg(" +++ Updated Bond")

  case BLE_EVBLEMSGID_ENCRYPTED
    DbgMsg(" +++ Encrypted Connection")

  case BLE_EVBLEMSGID_CONN_TO_BONDED_MASTER
    DbgMsgVal(" -- Conn to Bonded Master ",nCtx)

  case BLE_EVBLEMSGID_AUTH_KEY_REQUEST
    DbgMsgVal(" +++ Auth Key Request, type=",nCtx)

  case BLE_EVBLEMSGID_CONN_PARMS_UPDATE
    //ShowConnParms(nCtx)

  case BLE_EVBLEMSGID_CONN_PARMS_UPDATE_FAIL
    DbgMsg(" ??? Conn Parm Negotiation FAILED")

  case else
    DbgMsgVal("Unknown Ble Msg", nMsgId)
  endselect
endfunc 1
//==============================================================================
// This handler is called when a BLE device disconnects
//==============================================================================
function HndlrDiscon(nCtx,nRsn) as integer
	print "something must happen here\n"
endfunc 1 

//==============================================================================
//==============================================================================
function HandlerPrimSvc(hConn,hUuid,hStart,hEnd) as integer
  //select gcState
 // case 0
	sAttr = hStart
	eAttr = hEnd
	if command == BLUEZ_COMMAND_GATTTOOL_PRIMARY then
		print "\n"
		print "attr handle = ";integer.h' hStart;"  ,end grp handle = ";integer.h' hEnd;//")"
		//print "hConn = ";integer.h' hConn;", 
		print "  uuid : ";integer.h' hUuid
		rc = BleDiscServiceNext(hz)
		if rc != 0 then 
			print "\n"
			BleGattcClose()
			exitfunc 1 
		endif
	
	elseif command == BLUEZ_COMMAND_GATTTOOL_CHARACTERISTICS then
		rc = BleDiscCharFirst(hz,0,sAttr,eAttr)
	
	endif
	
	
endfunc 1

//==============================================================================
//==============================================================================
function HandlerCharDisc(hConn,hUuid,cProp,hVal,hiUuid) as integer
    //print "hConn=";integer.h' hConn;",hCharUuid=";integer.h' hUuid;",hIncUuid=";hiUuid
    //print ",hVal=";hVal;",Props=";integer.h' cProp;")"
	
	print "\n"
	print "handle = ";integer.h' hConn
	print ", char properties = ";integer.h' cProp
	print ", char value handle = ";integer.h' hVal
	print ", uuid = ";integer.h' hUuid
	
	//rc=BleGattcRead(hConn,0,0)
	rc = BleDiscCharNext(hz)
	if rc != 0 then
		//print "\n";rc
		rc = BleDiscServiceNext(hz)
			if rc !=0 then
				BleGattcClose()
			endif
		exitfunc 1
	endif
	
endfunc 1
//==============================================================================
//==============================================================================
function HandlerAttrRead(hConn,hAttr,nSts) as integer
  
  print "Entered HandlerAttrRead\n"
  //dim a$,ofst  
  //print "\nEVATTRREAD(hConn=";hConn;",handle=";hAttr;",status=";nSts;")"
  //if nSts == 0 then
  //  rc = BleGattcReadData(hConn,hAttr,ofst,a$)
  //  if rc==0 then
  //    print "\n >BleGattcReadData(data=";StrHexize$(a$);",offset=";ofst;")"
  //    print "\n                  (data=";StrEscape$(a$);")"
  //  endif
  //endif        
endfunc 1
//==============================================================================
//==============================================================================

//==============================================================================
// This handler is called when data has arrived at the serial port
//==============================================================================
function HandlerUartRxCmd() as integer
	dim nMatch
	
	
	//Youssif: why is the 13 used?
	nMatch=UartReadMatch(stRsp$,13)
	if nMatch!=0 then
		//CR exists in the input buffer
		urtcmd$ = strsplitleft$(stRsp$, nMatch)
		exitfunc OnUartCmd()
	endif
endfunc 1

//******************************************************************************

//******************************************************************************
// Equivalent to main() in C
//******************************************************************************

//------------------------------------------------------------------------------
// Enable synchronous event handlers
//------------------------------------------------------------------------------
OnEvent  EVUARTRX					call HandlerUartRxCmd

OnEvent EVINQRESP					call HandlerInqResp
OnEvent	EVBTC_INQUIRY_TIMEOUT		call HandlerBtcInqTimOut	

OnEvent  EVSPPCON                 	call HandlerSppCon
OnEvent  EVBTC_SPP_CONN_TIMEOUT   	call HandlerSppConnTimOut
OnEvent  EVSPPDISCON              	call HandlerSppDiscon
OnEvent  EVBTC_SPP_DATA_RECIEVED  	call HandlerSppData

OnEvent  EVBTC_PAIR_REQUEST       	call HandlerPairReq
OnEvent  EVBTC_PIN_REQUEST        	call HandlerPinReq
OnEvent  EVBTC_PAIR_RESULT        	call HandlerPairRes

OnEvent EVBLE_ADV_REPORT			call HandlerAdvRpt
OnEvent  EVBLE_SCAN_TIMEOUT       	call HandlerBlrScanTimOut
OnEvent  EVBLEMSG                 	call HandlerBleMsg
OnEvent EvDiscon                  	call HndlrDiscon

OnEvent  EVDISCPRIMSVC            	call HandlerPrimSvc
OnEvent  EVDISCCHAR               	call HandlerCharDisc
OnEvent EVATTRREAD 					call HandlerAttrRead

//OnEvent 
//==============================================================================
//==============================================================================
sub Initialise()
	InitBtDevice()
	print "\nBLUETOOTH EXPLORTER v0.2\n"
endsub

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
Initialise()

UartRsp(rc)
//------------------------------------------------------------------------------
// Wait for a synchronous event.
// An application can have multiple <WaitEvent> statements
//------------------------------------------------------------------------------
WaitEvent