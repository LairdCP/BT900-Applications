//******************************************************************************
// Laird Technologies (c) 2014
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++                                                                      ++
// +++++  When UwTerminal downloads the app it will store it as a filenname   ++
// +++++  which consists of all characters up to the first . and excluding it ++
// +++++                                                                      ++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// This app provides for a command interface over the uart similar to the BlueZ
// commands for Linux as follows
//		
//		hcitool dev 		Display local devices
//		hcitool inq 		Inquire remote devices
//		hcitool scan		Scan for remote devices
//		hcitool name		Get name from remote device
//		hcitool con 		Display active connections
//		hcitool pair		Pair with remote device
//		hcitool unpair  	Unpair from remote device
//		hcitool leadv		Start LE advertisement
//		hcitool noleadv		Stop LE advertisement
//		hcitool lescan      Start LE scan
//		hcitool lecc        Create a LE Connection
//		hcitool ledc        Disconnect a LE Connection
//
//
//		gatttool 
//		gatttool --primary        	Primary Service Discovery
//		gatttool --characteristics	Characteristics Discovery
//		gatttool --char-read      	Characteristics Value/Descriptor Read
//		gatttool --char-write    	Characteristics Value Write Without Response
//		gatttool --char-desc     	Characteristics Descriptor Discovery
//		gatttool --listen        	Listen for notifications and indications
//
//		Options:
//		-b, --device=MAC	Specify remote Bluetooth address
//		-l, --sec-level		Set security level. Default: low
//
//
//
//		hciconfig auth  				Enable Authentication
//		hciconfig noauth				Disable Authentication
//		hciconfig piscan				Enable Page and Inquiry scan
//		hciconfig noscan				Disable scan
//		hciconfig iscan 				Enable Inquiry scan
//		hciconfig pscan 				Enable Page scan
//		hciconfig name   	[name]		Get/Set local name
//		hciconfig inqtpl	[level]		Get/Set inquiry transmit power level
//		hciconfig inqmode	[mode]		Get/Set inquiry mode
//		hciconfig inqtype	[type]		Get/Set inquiry scan type
//		hciconfig sspmode	[mode]		Get/Set Simple Pairing Mode
//		hciconfig putkey	<bdaddr>		Store link key on the device
//		hciconfig delkey	<bdaddr>		Delete link key from the device
//		hciconfig version				Display version information
//		hciconfig leadv  				Enable LE advertising
//		hciconfig noleadv				Disable LE advertising
//		hciconfig letpl	[level]		Get/Set LE transmit power level
//
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//******************************************************************************
// Definitions
//******************************************************************************


        // Number of connections
#define NUM_OF_CONNS                         8

// BLE EVENT MSG IDs
#define BLE_EVBLEMSGID_CONNECT                          0 // msgCtx = connection handle
#define BLE_EVBLEMSGID_DISCONNECT                       1 // msgCtx = connection handle
#define BLE_EVBLEMSGID_IMMEDIATE_ALERT_SERVICE_ALERT    2 // msgCtx = alert level
#define BLE_EVBLEMSGID_LINKLOSS_SERVICE_ALERT           3 // msgCtx = alert level
#define BLE_EVBLEMSGID_SERVICE_ERROR                    4 // msgCtx = resultcode
#define BLE_EVBLEMSGID_HTS_INDICATION_STATE             5 // msgCtx = new indication state 0=off, 1=on
#define BLE_EVBLEMSGID_HTS_INDICATION_CNF               6 // msgCtx = not used
#define BLE_EVBLEMSGID_BPS_INDICATION_STATE             7 // msgCtx = new indication state 0=off, 1=on
#define BLE_EVBLEMSGID_BPS_INDICATION_CNF               8 // msgCtx = not used
#define BLE_EVBLEMSGID_DISPLAY_PASSKEY                  9 // msgCtx = passcode to display
#define BLE_EVBLEMSGID_NEW_BOND                        10 // msgCtx = connection handle
#define BLE_EVBLEMSGID_AUTH_KEY_REQUEST                11 // msgCtx = 1 for passkey, 2 for 16 byte OOB data
#define BLE_EVBLEMSGID_HRS_NOTIFICATION_STATE          12 // msgCtx = new notification state 0=off, 1=on

// #define FUTURE_USE                                   13
#define BLE_EVBLEMSGID_CONN_PARMS_UPDATE               14 // msgCtx = connection handle
#define BLE_EVBLEMSGID_CONN_PARMS_UPDATE_FAIL          15 // msgCtx = connection handle
#define BLE_EVBLEMSGID_CONN_TO_BONDED_MASTER           16 // msgCtx = connection handle
#define BLE_EVBLEMSGID_UPDATED_BOND                    17 // msgCtx = connection handle
#define BLE_EVBLEMSGID_ENCRYPTED                       18 // msgCtx = connection handle
#define BLE_EVBLEMSGID_POWER_FAILURE_WARNING           19 // msgCtx = current supply voltage
#define BLE_EVBLEMSGID_UNENCRYPTED                     20 // msgCtx = connection handle
#define BLE_EVBLEMSGID_DEVICENAME_WRITE                21 // msgCtx = connection handle 

// BLUEZ COMMAND IDs: HCITOOL
#define BLUEZ_COMMAND_HCITOOL_DEV						1
#define BLUEZ_COMMAND_HCITOOL_INQ						2
#define BLUEZ_COMMAND_HCITOOL_SCAN						3
#define BLUEZ_COMMAND_HCITOOL_NAME						5
#define BLUEZ_COMMAND_HCITOOL_INFO						6
#define BLUEZ_COMMAND_HCITOOL_SPINQ						7
#define BLUEZ_COMMAND_HCITOOL_EPINQ						8
#define BLUEZ_COMMAND_HCITOOL_CMD						9
#define BLUEZ_COMMAND_HCITOOL_CON						10
#define BLUEZ_COMMAND_HCITOOL_PAIR						11
#define BLUEZ_COMMAND_HCITOOL_UNPAIR					12
#define BLUEZ_COMMAND_HCITOOL_SR						13
#define BLUEZ_COMMAND_HCITOOL_CPT						14
#define BLUEZ_COMMAND_HCITOOL_RSSI						15
//#define BLUEZ_COMMAND_HCITOOL_SCAN						16
#define BLUEZ_COMMAND_HCITOOL_LQ						17
#define BLUEZ_COMMAND_HCITOOL_TPL						18
#define BLUEZ_COMMAND_HCITOOL_AFH						19
#define BLUEZ_COMMAND_HCITOOL_LP						20
#define BLUEZ_COMMAND_HCITOOL_LST						21
#define BLUEZ_COMMAND_HCITOOL_ENC						23
#define BLUEZ_COMMAND_HCITOOL_KEY						24
#define BLUEZ_COMMAND_HCITOOL_CLKOFF					25
#define BLUEZ_COMMAND_HCITOOL_CLOCK						26
#define BLUEZ_COMMAND_HCITOOL_LESCAN					27
#define BLUEZ_COMMAND_HCITOOL_LEWLADD					28
#define BLUEZ_COMMAND_HCITOOL_LEWLRM					29
#define BLUEZ_COMMAND_HCITOOL_LEWLSZ					30
#define BLUEZ_COMMAND_HCITOOL_LEWLCLR					31
#define BLUEZ_COMMAND_HCITOOL_LECC						32
#define BLUEZ_COMMAND_HCITOOL_LEDC						33
#define BLUEZ_COMMAND_HCITOOL_LECUP						34

// BLUEZ COMMAND IDs: GATTTOOL
#define BLUEZ_COMMAND_GATTTOOL_PRIMARY					41
#define BLUEZ_COMMAND_GATTTOOL_CHARACTERISTICS			42
#define BLUEZ_COMMAND_GATTTOOL_CHAR_READ				43
#define BLUEZ_COMMAND_GATTTOOL_CHAR_WRITE				44
#define BLUEZ_COMMAND_GATTTOOL_CHAR_WRITE_REQ			45
#define BLUEZ_COMMAND_GATTTOOL_CHAR_DESC				46
#define BLUEZ_COMMAND_GATTTOOL_LISTEN					47

// BLUEZ COMMAND IDs: GATTTOOL
#define BLUEZ_COMMAND_GATTTOOL_SERVER_UUID				51

// BLUEZ COMMAND IDs: RFCOMM
#define BLUEZ_COMMAND_RFCOMM_CONNECT					60

// APP RUN MODES
#define NORMAL_MODE                                 	0
#define RFCOMM_MODE                          			1
#define GATTTOOL_INTERACTIVE_MODE						2
#define GATTTOOL_LISTEN									3



//******************************************************************************
// Global Variable Declarations
//******************************************************************************
dim rc
dim stRsp$ 			        //Uart rx data is stored here
dim ok$,er$,pr$
dim urtcmd$                 // cmd line from uart
dim tkn$,tlen               // used by command parser
dim urts                    // will be <0 if uart parser suspended
dim hc[NUM_OF_CONNS+1]      // contains connection handles
dim conns                   // number of connections
dim name$					// local device name
dim addr$					// address of device being connected to

dim gcState                 // gatt client state, 0=IDLE, 1=TableMapping
dim sAttr
dim eAttr

dim prAddr$              				// BT address of last device pairing requested from or initiated with
dim hcSpp                   			// handle of connection to use for VSP service

dim command : command = 0				// Currently active BlueZ command
dim nDiscv : nDiscv = 1					// The device is discoverable by default
dim nConn : nConn = 1 					// The device is connectable by default
dim nPair : nPair = 1					// The device is pairable by default					
dim inqtype	: inqtype = 0				// Inquiry Type: 0 General, 1 Limited
dim inqmode	: inqmode = 2				// Inquiry Mode: 0 for Standard, 1 for with RSSI, 2 for Extended)
dim sspmode : sspmode = 1				// SSP Mode: 0 for disabled, 1 for enabled 
dim inqtpl : inqtpl=4						// Inquiry transmit power level
dim letpl : letpl = 4					// LE Tx Power level in dBm
dim gattLsn : gattLsn = 0				// If Lsn = 1, notifications will be shown

dim mjVersion : mjVersion=0			// Major version number
dim mnVersion : mnVersion=94				// Minor version number
dim conHdl								// global connection handle of the current connection being serviced
dim chrHdl								// global characteristic handle of the current characteristic being serviced
dim valHdl								// global characteristic value handle of the current characteristic value handle being serviced

dim carCnt                  //count variable for number of times '^' entered
//******************************************************************************
// Initialise Global Variable
//******************************************************************************

ok$    = "\nOK"
er$    = "\nERROR "
pr$    = "------->"
urts = 0					// not suspended

//==============================================================================
//==============================================================================
sub AssertResCode(resCode)
	if rc !=0 then
		print "error: ";integer.h' rc;"\n"
	endif
endsub 
//==============================================================================
// Initialise all connection handles
//==============================================================================
sub InitConnHandles()
  dim z
  for z=0 to (NUM_OF_CONNS)
    hc[z]=-1
  next
endsub
//==============================================================================
// Add the connection handle to the list of connection handles
//==============================================================================
function AcqConnHandle(hConn)
  dim z
  for z=1 to (NUM_OF_CONNS)
    if hc[z] == -1 then
	    hc[z]=hConn
      exitfunc z
    endif
  next

endfunc 0

//==============================================================================
// Release the connection handle from the array of conn handles
//==============================================================================
function RelConnHandle(hConn)
  dim z
  for z=1 to (NUM_OF_CONNS)
    if hc[z] == hConn then 
      hc[z]=-1
      exitfunc z
    endif
  next
endfunc 0
//------------------------------------------------------------------------------
//** #include the correct library file for the smartBASIC module being used 
//------------------------------------------------------------------------------
#include "lib\cmd.bluez.manager.sblib"		//comment out lines above if you are using the bluez commands

//==============================================================================
//==============================================================================
sub UartRsp(rsp as integer)
  //if rsp == 0 then
    print pr$
  //elseif rsp > 0 then 
  //  print er$;integer.h' rsp;pr$
  //endif
  urts = rsp
endsub

//==============================================================================
// Initialise the Bluetooth device
// Set the device to be disoverable, connectable, pairable, 
// Set the inquiry type to be general, inquiry mode to be extended
//==============================================================================
sub InitBtDevice()
	
	dim nHandle
	
	// Set the name of the local Bluetooth device
	name$ = SYSINFO$(4)
	name$ = right$(name$, 6)
	name$ = StrHexize$(name$)
	name$ = "cmdZ-" + name$
	rc = BTCSETFRIENDLYNAME (name$)
	AssertResCode(rc)
	
	// Configure classic BT radio
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Set device is discoverable with 300s discoverability timeout
	rc = BtcSetDiscoverable(1, 300)
	AssertResCode(rc)
	// Set device to be connectable
	rc = BtcSetConnectable(1)
	AssertResCode(rc)
	// Set the device to be pairable
	rc = BtcSetPairable(1)
	AssertResCode(rc)															
	// Set inquiry type to be general
	rc = BtcInquiryConfig(0, inqtype)
	AssertResCode(rc)
	// Set inquiry mode to be extended
	rc = BtcInquiryConfig(1, inqmode)
	AssertResCode(rc)
	// Open Spp
	rc = btcSppOpen(nHandle)
	AssertResCode(rc)
	sspmode = 1
	
endsub											
//==============================================================================
// Print the Help menu
//==============================================================================
function _Help()

	print "Available Commands: \n"
	print "\n"
	print "	help\n"
	print "	hcitool\n"
	print "	gatttool\n"
	print "	rfcomm\n"
	print "	hciconfig\n"
	print "	quit/exit\n"
	print "\n"
	print "For more information on the usage of each command use:\n"
	print "<command> --help\n\n"

endfunc 1

//==============================================================================
// print the hcitool help menu
//==============================================================================
function _HciHelp()

	print "Usage:\n"
	print "	hcitool <command> [command parameters]\n"
	print "\n"
	print "Commands:\n"
	print "	dev 		Display local devices\n"
	print "	inq 		Inquire remote devices\n"
	print "	scan		Scan for remote devices\n"
	print "	name		Get name from remote device\n"
	print "	con 		Display active connection handles\n"
	print "	pair		Pair with remote device\n"
	print "	unpair  	Unpair from remote device\n"
	print "	leadv		Start LE advertisement\n"
	print "	noleadv 	Stop LE advertisement\n"
	print "	lescan      Start LE scan\n"
	print "	lecc        Create a LE Connection\n"
	print "	ledc        Disconnect a LE Connection\n"
	print "\n"
	print "For more information on the usage of each command use:\n"
	print "	hcitool <command> --help\n\n"
	
endfunc 1
//==============================================================================
// Print the gatt help menu
//==============================================================================
function _GattHelp()

	print "Usage:\n"
	print "	gatttool [OPTION...] <command>\n"
	print "\n"
	print "GATT commands\n"
	print "	--primary        						Primary Service Discovery\n"
	print "	--characteristics						Characteristics Discovery\n"
	print "	--char-read      						Characteristics Value/Descriptor Read\n"
	print "	--char-write    						Characteristics Value Write Without Response\n"
	print "	--char-desc     						Characteristics Descriptor Discovery\n"
	print "	--listen        						Listen for notifications and indications\n"
	print "\n"
	print "Options:\n"
	print "	-b, --device=MAC						Specify remote Bluetooth address\n"
	print "	-l, --sec-level=[low | medium | high]		Set security level. Default: low\n"	
	print "\nFor more information on the usage of each command use:\n"
	print "	gatttool <command> --help\n\n"
	
endfunc 1

//==============================================================================
// Print the hciconfig help menu
//==============================================================================
function _HciCfgHelp() as integer
	
	print "Usage:\n"
	print "	hciconfig <command> [command parameters]\n\n"
	print "Commands:\n"
	print "	auth  				Enable Authentication\n"
	print "	noauth				Disable Authentication\n"
	print "	piscan				Enable Page and Inquiry scan\n"
	print "	noscan				Disable scan\n"
	print "	iscan 				Enable Inquiry scan\n"
	print "	pscan 				Enable Page scan\n"
	print "	name   	[name]		Get/Set local name\n"
	print "	inqtpl	[level]		Get/Set inquiry transmit power level\n"
	print "	inqmode	[mode]		Get/Set inquiry mode\n"
	print "	inqtype	[type]		Get/Set inquiry scan type\n"
	print "	sspmode	[mode]		Get/Set Simple Pairing Mode\n"
	print "	putkey	<bdaddr>		Store link key on the device\n"
	print "	delkey	<bdaddr>		Delete link key from the device\n"
	print "	version				Display version information\n"
	print "	leadv  				Enable LE advertising\n"
	print "	noleadv				Disable LE advertising\n"
	print "	letpl		[level]		Get/Set LE transmit power level\n"
	print "\n"

endfunc 1
//==============================================================================
// Print the rfcomm help menu
//==============================================================================
function _rfcommHelp()

	print "Usage:\n"
	print "		rfcomm connect <bdaddr>\n"

endfunc 1
//==============================================================================
// Extract the hcitool command
//==============================================================================
function _Hci()
	
	while ExtractStrToken(urtcmd$, tkn$)!=0
		if strcmp(tkn$,"help")==0 then
			rc = _hciHelp()
			exitfunc 1
	
		elseif strcmp(tkn$,"dev")==0 then
			// Display the address of the local device
			rc = _hciDev()								
	
		elseif strcmp(tkn$,"inq")==0 then				
			command = BLUEZ_COMMAND_HCITOOL_INQ
			// Inquire for remote devices (show address only)
			rc = _hciInq()							
	
		elseif strcmp(tkn$,"scan")==0 then
			// Scan for remote devices (show address and name)
			command = BLUEZ_COMMAND_HCITOOL_SCAN
			rc = _hciScan()							
	
		elseif strcmp(tkn$,"name")==0 then
			// Get name from remote device
			command = BLUEZ_COMMAND_HCITOOL_NAME
			rc = _hciName()							

		elseif strcmp(tkn$,"con")==0 then
			// Display active connection handles
			command = BLUEZ_COMMAND_HCITOOL_CON
			rc = _hciCon()							
	
	
		elseif strcmp(tkn$, "pair")==0 then
			// Create connection to remote device
			command = BLUEZ_COMMAND_HCITOOL_PAIR
			rc = _hciPair()
	
		elseif strcmp(tkn$, "unpair")==0 then
			// Disconnect from remote device
			command = BLUEZ_COMMAND_HCITOOL_UNPAIR
			rc = _hciUnpair()
	
		elseif strcmp(tkn$, "leadv")== 0 then
			// LE advertise
			rc = _hciLeAdv()
			
		
		elseif strcmp(tkn$, "noleadv")== 0 then
			// LE advertise
			rc = _hciNoLeAdv()
			
	
		elseif strcmp(tkn$, "lescan")==0 then
			// Start LE scan
			rc = _hciLeScan()
	
		elseif strcmp(tkn$, "lecc")==0 then
			// Create a LE connection
			rc = _hciLeCc()
	
		elseif strcmp(tkn$, "ledc")==0 then
			// Disconnect a LE Connection
			rc = _hciLeDc()
			
		endif
		
	endwhile
	
endfunc 1
//==============================================================================
// Extract the gatttool command
//==============================================================================
function _Gatt()
	
	while ExtractStrToken(urtcmd$, tkn$)!= 0
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		if strcmp(tkn$,"help")==0 then
			rc = _GattHelp()
			exitfunc 1

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		elseif strcmp(tkn$,"primary")==0 then
			command = BLUEZ_COMMAND_GATTTOOL_PRIMARY
			rc = _GattPrimary()

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		elseif strcmp(tkn$,"characteristics")==0 then
			command = BLUEZ_COMMAND_GATTTOOL_CHARACTERISTICS
			rc = _GattChar()
	
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		elseif strcmp(tkn$, "char")==0 then 
			strshiftleft(urtcmd$, 1)
			rc = ExtractStrToken(urtcmd$, tkn$)
			if strcmp(tkn$, "read")==0 then
				command = BLUEZ_COMMAND_GATTTOOL_CHAR_READ
				rc = _GattCharRead()
			elseif strcmp(tkn$, "write")==0 then
				command = BLUEZ_COMMAND_GATTTOOL_CHAR_WRITE
				rc = _GattCharWrite()
			elseif strcmp(tkn$, "desc")==0 then
				command = BLUEZ_COMMAND_GATTTOOL_CHAR_DESC
				rc = _GattCharDesc()
			endif
			
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		elseif strcmp(tkn$, "server")==0 then 
			//create gatt server
			rc = _GattSrvr()
			AssertResCode(rc)
			
		endif
	endwhile
	
endfunc 1
//==============================================================================
// Extract the hciconfig command
//==============================================================================
function _HciCfg()
	
	dim s$, val
	s$ = urtcmd$
	while ExtractStrToken(s$, tkn$)!= 0
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		if strcmp(tkn$,"help")==0 then
			rc = _HciCfgHelp()
			exitfunc 1
	
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		elseif strcmp(tkn$,"auth")==0 then 
			rc = BtcSetConnectable(1)
			AssertResCode(rc)
			rc = BtcSetPairable(1)
			AssertResCode(rc)
		
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		elseif strcmp(tkn$,"noauth")==0 then
			rc = BtcSetPairable(0)
			AssertResCode(rc)
	
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		elseif strcmp(tkn$,"name")==0 then 
			tlen = ExtractStrToken(s$,tkn$)
			if tlen == 0 then
				rc = BtcGetFriendlyName(s$)
				AssertResCode(rc)
				print s$;"\n"
			else
				name$ = tkn$ + s$
				rc = BtcSetFriendlyName(name$)
				AssertResCode(rc)
				exitfunc 1
			endif
	
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		elseif strcmp(tkn$,"piscan")==0 then 
			//Enable inquiry scan and page scan (default)
			nDiscv = 1 
			rc = BtcSetDiscoverable(nDiscv, 300)
			AssertResCode(rc)
			rc = BtcSetConnectable(nConn)
			AssertResCode(rc)
	
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		elseif strcmp(tkn$,"pscan")==0 then 
			//Enable page scan
			nDiscv = 1 
			rc = BtcSetDiscoverable(nDiscv, 300)
			AssertResCode(rc)
	
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		elseif strcmp(tkn$,"iscan")==0 then 
			//Enable inquiry scan
			nDiscv = 1
			rc = BtcSetDiscoverable(nDiscv, 300)
			AssertResCode(rc)
	
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		elseif strcmp(tkn$,"noscan")==0 then 
			//The adapter in not detectable by other devices and will not accept any incoming connections
			nDiscv = 0 
			rc = BtcSetDiscoverable(nDiscv, 300)
			AssertResCode(rc)
			rc = BtcSetConnectable(nConn)
			AssertResCode(rc)
		
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		elseif strcmp(tkn$, "inqtpl")==0 then
			// Get/set the transmit power level
			if ExtractStrToken(s$, tkn$) == 0  then
				// Get the transmit power level
				print "Inquiry transmit power level : ";inqtpl;"\n"
			else 
				// Set the transmit power level
				if strcmp(tkn$,"-")==0 then
					rc = ExtractStrToken(s$, tkn$)
					val = StrValDec(tkn$)
					if (val > 70) then
						print "Invalid power value. Valid range is from -70 to 20 dBm\n"
					else
						inqtpl = val*-1
					endif
				else
					val = StrValDec(tkn$)
					if (val > 20) then
						print "Invalid power value. Valid range is from -70 to 20 dBm\n"
					else
						inqtpl =  val
					endif
				endif
				rc = BtcInquiryConfig(3,inqtpl)
				AssertResCode(rc)
			endif
		
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		elseif strcmp(tkn$,"inqmode")==0 then 
			//Get/Set Inquiry mode
			if ExtractStrToken(s$, tkn$) == 0  then
				// Get inquiry mode
				if inqmode == 0 then
					print "Inquiry mode: Standard Inquiry\n"
				elseif inqmode == 1 then
					print "Inquiry mode: Inquiry with RSSI\n"
				elseif inqmode == 2 then
					print "Inquiry mode: Inquiry with RSSI or Extended Inquiry\n"
				else
					print "Invalid inquiry mode detected. Please set inquiry mode to 0, 1, or 2\n"
				endif
			else
				val = StrValDec(tkn$)
				if val >= 0 && val < 3 then
					inqmode = val
					rc = BtcInquiryConfig(1, inqmode)
					AssertResCode(rc)
				else 
					print "Invalid inquiry mode. Valid values are 0, 1, and 2\n"
				endif
			endif
		
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		elseif strcmp(tkn$,"inqtype")==0 then 
			//Get/Set Inquiry type
			if ExtractStrToken(s$, tkn$) == 0  then
				// Get inquiry type
				if inqtype == 0 then
					print "Inquiry scan type: General Inquiry Scan\n"
				elseif inqtype == 1 then
					print "Inquiry scan type: Limited Inquiry Scan\n"
				else
					print "Invalid inquiry type detected. Please set inquiry type to 0, or 1\n"
				endif
			else
				val = StrValDec(tkn$)
				if val >= 0 && val < 2 then
					inqtype = val
					rc = BtcInquiryConfig(0, inqtype)
					AssertResCode(rc)
				else 
					print "Invalid inquiry type. Valid values are 0 and 1\n"
				endif
			endif
		
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		elseif strcmp(tkn$, "sspmode")==0 then
			dim hn
			// Get/Set Simple Pairing Mode
			if ExtractStrToken(s$, tkn$) == 0  then
			// Get Simple Pairing Mode
				print "Simple Pairing Mode: "
				if sspmode == 0 then 
					print "Disabled\n"
				else 
					print "Enabled\n"
				endif
			else
				val = StrValDec(tkn$)
				if val == 0 then
					rc = BtcSppClose(hn)
					AssertResCode(rc)
					sspmode = 0
				elseif val == 1 then
					rc = BtcSppOpen(hn)
					AssertResCode(rc)
					sspmode = 1
				else
					print "Invalid ssp mode. Valid values are 0 and 1\n"
				endif
			endif
			
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		elseif strcmp(tkn$, "putkey")==0 then
			//store link key on the device
			if ExtractStrToken(s$, tkn$) == 0 then
				print "MAC address not supplied\n"
			else
				tkn$ = strdehexize$(tkn$)
				rc = BtcBondingPersistKey(tkn$)
				AssertResCode(rc)
				if rc == 0 then
					print "Link key made persistent\n"
				endif
			endif
		
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		elseif strcmp(tkn$, "delkey")==0 then
			//delete link key on the device
			if ExtractStrToken(s$, tkn$) == 0 then
				print "MAC address not supplied\n"
			else
				tkn$ = strdehexize$(tkn$)
				rc = BtcBondingEraseKey(tkn$)
				AssertResCode(rc)
				if rc == 0 then
					print "Link key erased\n"
				endif
			endif
			
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		elseif strcmp(tkn$, "leadv")==0 then
			dim a$
			rc = BleAdvertStart(0,a$,25,6000,0)
			AssertResCode(rc)
			
		
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		elseif strcmp(tkn$, "noleadv")==0 then
			rc = BleAdvertStop()
			AssertResCode(rc)
			
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		elseif strcmp(tkn$, "letpl")==0 then
			// Get/set the LE transmit power level
			if ExtractStrToken(s$, tkn$) == 0  then
				// Get the LE transmit power level
				print "LE transmit power level : ";letpl;"\n"
			else 
				// Set the LE transmit power level
				if strcmp(tkn$,"-")==0 then
					rc = ExtractStrToken(s$, tkn$)
					val = StrValDec(tkn$)
					if (val > 20) then
						print "Invalid power value. Valid range is from -20 to 8 dBm\n"
					else
						letpl = val*-1
					endif
				else
					val = StrValDec(tkn$)
					if (val > 8) then
						print "Invalid power value. Valid range is from -20 to 8 dBm\n"
					else
						letpl =  val
					endif
				endif
				rc = BleTxPowerSet(letpl)
				AssertResCode(rc)
			endif
		
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		elseif strcmp(tkn$, "version")==0 then
			dim fw, X, Y, Z
			fw = SYSINFO(3)
			X = (fw >> 24) & 0xFF
			Y = (fw >>  8) & 0xFFFF
			Z = (fw      ) & 0xFF
			print "\nApp Version: cmdZ Manager Version ";mjVersion;".";mnVersion;"\n"
			print "Device Name: ";BleGetDeviceName$();"\n"
			print "Firmware: 9.";X;".";Y;".";Z;"\n"
			print "Manufacturer: Laird Technologies\n"
			
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			
		
		endif
	endwhile
	
endfunc 1
//==============================================================================
// Extract the rfcomm command
//==============================================================================
function _rfcomm()
	
	while ExtractStrToken(urtcmd$, tkn$)!= 0
		if strcmp(tkn$, "help")==0 then
			rc = _rfcommHelp()
			exitfunc 1

		elseif strcmp(tkn$, "connect")==0 then
			command = BLUEZ_COMMAND_RFCOMM_CONNECT
			rc = _rfcommConnect()
	
		elseif strcmp(tkn$, "write")==0 then
			rc = _rfcommWrite()
			exitfunc 1
	
		elseif strcmp(tkn$, "bind")==0 then
			rc = _rfcommBind()
		
		elseif strcmp(tkn$,"-")!=0 then
			print "Unknown command - \22";tkn$;"\22\n"
	
		endif
	endwhile
	
endfunc 1
//==============================================================================
// Extract the received Uart command
//==============================================================================
function OnUartCmd() as integer

	// get first token
	tlen = ExtractStrToken(urtcmd$,tkn$) 
	
	if strcmp(tkn$,"hcitool")==0 then
		rc = _Hci()
      
    elseif strcmp(tkn$,"gatttool")==0 then
		rc = _Gatt()
	  
	elseif strcmp(tkn$,"hciconfig")==0 then
		rc = _HciCfg()
		
	elseif strcmp(tkn$, "rfcomm")==0 then
		rc = _rfcomm()
	  
	elseif strcmp(tkn$, "help")==0 then
		rc = _Help()
	
	elseif strcmp(tkn$,"exit")==0 || strcmp(tkn$,"quit")==0  then
      reset(0)
	
	elseif strcmp(tkn$,"")==0 then
		//exitfunc 1

	else
		print tkn$;": command not found\n"
	endif

	print pr$
	
endfunc 1

//==============================================================================
// gatt status error codes
//==============================================================================
function _gattStatus(status as integer)
	
	print "ATT Error: "
	select status
		
		case H'0101
			print "Invalid attribute handle\n"
			
		case H'0102
			print "Read not permitted\n"
			
		case H'0103
			print "Write not permitted\n"
			
		case H'0104
			print "Used in ATT as invalid PDU\n"
			
		case H'0105
			print "Authenticated link required\n"
			
		case H'0106
			print "Used in ATT as request not supported\n"
			
		case H'0107
			print "Offset specified was past the end of the attribute\n"
			
		case H'0108
			print "Used in ATT as insufficient authorisation\n"
			
		case H'0109
			print "Used in ATT as prepare queue full\n"
			
		case H'010A
			print "Used in ATT as attribute not found\n"
			
		case H'010B
			print "Attribute cannot be read or written using read/write requests\n"
			
		case H'010C
			print "Encryption key size used is insufficient\n"
			
		case H'010D
			print "Invalid value size\n"
			
		case H'010E
			print "Very unlikely error\n"
			
		case H'010F
			print "Encrypted link required\n"
			
		case H'0110
			print "Attribute type is not a supported grouping attribute\n"
			
		case H'0111
			print "Encrypted link required\n"
			
		case H'0180
			print "Application range begin\n"
			
		case H'019F
			print "Application range end\n"
			
		case H'01FE
			print "Profile and service error: Procedure already in progress\n"
			
		case H'01FF
			print "Profile and service error: Out of range\n"
			
		case else
			print "Unknown status\n"
			
		endselect
	print pr$
		
endfunc 1

//******************************************************************************
// Handler definitions
//******************************************************************************

//==============================================================================
// This handler is called when there is an inquiry report waiting to be read 
// Algorithm will prevent display of data from the same peer consecutively 
//==============================================================================
function HandlerInqResp(respType) as integer
	
	dim ad$,dta$,ndx,rsi,tag, name$
	
	// Get the report from the inquiry response
	rc = BtcInquiryGetReport(ad$,dta$,ndx,rsi)
	
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if command == BLUEZ_COMMAND_HCITOOL_INQ then
		print "\n		"; StrHexize$(ad$)
			
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	elseif command == BLUEZ_COMMAND_HCITOOL_SCAN then
		print "\n		"; StrHexize$(ad$)
		if respType == 2 then
			//Get local name
			tag = 0x09
			rc=BtcGetEIRbyTag(dta$, tag, name$)
			//AssertResCode(rc)
			if rc == 0x5703 then
				tag = 0x08
				rc=BtcGetEIRbyTag(dta$, tag, name$)
				//AssertResCode(rc)
			endif
				
			if rc == 0 then
				print "  ";name$
			endif		
		else
			print "  n/a"
		endif
		
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	elseif command == BLUEZ_COMMAND_HCITOOL_NAME then
		// Only looking for name of specified address
		if strcmp(ad$, addr$)!=0 then
			exitfunc 1
			
		else
			print "\n		"; StrHexize$(ad$)
			if respType == 2 then
				//Get local name
				tag = 0x09
				rc=BtcGetEIRbyTag(dta$, tag, name$)
				if rc == 0x5703 then
					tag = 0x08
					rc=BtcGetEIRbyTag(dta$, tag, name$)
				endif
				
				if rc == 0 then
					print "  ";name$
				endif		
			
			else
				print "  n/a"
			endif
			// Found the device so cancel inquiry
			rc = BtcInquiryCancel()
			AssertResCode(rc)
			print "\n";pr$
		
		endif
	endif
	
endfunc 1
//==============================================================================
// Called after an SPP connection attempt
//==============================================================================
function HandlerSppCon(hConn, res) as integer
	
	dim hz, az, conAddr$
    //if connected successfully
	if res == 0 then
		hcSpp = hConn
		hz = AcqConnHandle(hConn)
		conns = conns + 1
		rc = BtcGetBDAddrFromHandle(hConn,conAddr$)
		print "\nConnected to ";strhexize$(conAddr$)
		print "\nType \22^^^\22 for hangup\n"
		rc=SendMsgApp(0,RFCOMM_MODE)
	else
		print "\nconnection failed: ";res;"\n";pr$
    endif        

endfunc 1
//==============================================================================
// Called when a connection attempt to an SPP device times out
//==============================================================================
function HandlerSppConnTimOut() as integer
    print "\n --- SPP Conn Attempt Timeout"
endfunc 1
//==============================================================================
// Called when an SPP disconnection occurs
//==============================================================================
function HandlerSppDiscon(hConn)
    dim hz, az
    hz = RelConnHandle(hConn)
    conns = conns - 1
    print "\nDisconnected\n";pr$ 
	rc=SendMsgApp(0,NORMAL_MODE)
endfunc 1
//==============================================================================
// This handler is called when there is an inquiry timeout
//==============================================================================
function HandlerBtcInqTimOut() as integer 
	print "\n";pr$
endfunc 1
//==============================================================================
// This handler is called when there is an inquiry timeout
//==============================================================================
function HandlerBtcDiscTimOut() as integer
	
	//Enable inquiry scan and page scan (default)
	rc = BtcSetDiscoverable(nDiscv, 300)
	AssertResCode(rc)
	
endfunc 1
//==============================================================================
// Called when data is received via SPP
//==============================================================================
function HandlerSppData()
    dim hPort, data$, rLen
    '//read and print data while there is data available to read
	while BtcSppRead(hPort, data$, rLen) == 0    
        if rLen>0 then
            //print"\nPort Handle: ";hPort; " Length: ";rLen;"\nData: ";data$;pr$
			print data$
        endif
    endwhile
endfunc 1
//==============================================================================
// Called when data is received via SPP in bridge mode
//==============================================================================
function HandlerSppDataBridge()
    dim hPort, data$, rLen
    
    // read and print data while there is data available to read
    while BtcSppRead(hPort, data$, rLen) == 0    
        if rLen>0 then
            print data$
        endif
    endwhile
endfunc 1
//==============================================================================
// Called when there is a pairing request from another device
//==============================================================================
function HandlerPairReq()
	
	dim s$
    rc=BtcGetPAIRRequestBDAddr(s$)
    prAddr$ = s$
    //print "\nPair Req: "; StrHexize$(s$);" \n"
	rc = BtcSendPAIRResp(1)
	AssertResCode(rc)
	
endfunc 1
//==============================================================================
// Called on a pin request from another device
//==============================================================================
function HandlerPINReq() 

	dim mac$
    rc=BtcGetPinRequestBDAddr(mac$)
	//AssertResCode(rc)
    if rc==0 then
        print "pin Req: "; StrHexize$(mac$);pr$;"\n"
    else
        //AssertResCode(rc,2273)
		print "pin error : ";integer.h' rc;"\n"
    endif
endfunc 1
//==============================================================================
// Called after a pairing attempt
//==============================================================================
function HandlerPairRes(res)
	
	if res == 0 then
		print "\npaired\n";pr$
	else
		print "\npairing attempt failed : ";res;"\n";pr$
	endif
endfunc 1
//==============================================================================
// This handler is called when there is an inquiry report waiting to be read 
// Algorithm will prevent display of data from the same peer consecutively 
//==============================================================================
function HandlerAdvRpt() as integer
	
	dim ad$,dta$,ndisc,rsi,tag, nm$
	rc = BleScanGetAdvReport(ad$,dta$,ndisc,rsi)
	AssertResCode(rc)
	while rc==0
		ad$ = right$(ad$,8)
		print "\n		";strhexize$(ad$)
		tag = 0x09
		rc = BLEGETADBYTAG(dta$, tag, nm$)
		if rc == 0x6060 then
			tag = 0x08
			rc = BLEGETADBYTAG(dta$, tag, nm$)
		endif
				
		if rc == 0 then
			print "  ";nm$
		endif
		rc = BleScanGetAdvReport(ad$,dta$,ndisc,rsi)
	endwhile
endfunc 1
//==============================================================================
// This handler is called when there is a Ble advert timeout
//==============================================================================
function HandlerBleAdvTimOut()
	
	print "\nadvert timed out\n";pr$
	dim a$
	rc = BleAdvertStart(0,a$,25,300000,0)
	AssertResCode(rc)
	
endfunc 1
//==============================================================================
// This handler is called when there is a Ble connection timeout
//==============================================================================
function HandlerBleConnTimOut() as integer
	
	print "\nCould not create connection: Connection timed out\n";pr$

endfunc 1
//==============================================================================
// This handler is called when there is a Ble scan timeout
//==============================================================================
function HandlerBlrScanTimOut() as integer 
	//print "\nScanning stopped via timeout\n"
	//UartRsp(0)
	print "\n";pr$
endfunc 1
//==============================================================================
// This handler is called when there is a BLE message
//==============================================================================
function HandlerBleMsg(BYVAL nMsgId AS INTEGER, BYVAL nCtx AS INTEGER) as integer
  dim hz
  
  select nMsgId
  case BLE_EVBLEMSGID_CONNECT
    hz = nCtx
	rc = AcqConnHandle(hz)
	conns = conns + 1
    //print "\nConnected\n";pr$
	print "\nConnection handle ";hz;"\n";pr$
	
    if hz == 0 then
      //Could not store the handle so drop the connection
      rc = BleDisconnect(nCtx)
	  AssertResCode(rc)
    else
      //accepted so display connection parameters
      //ShowConnParms(nCtx)
      //always assume most recent connection for VSP
      //hcVsp = hc[hz]
    endif
    
  case BLE_EVBLEMSGID_DISCONNECT
    // here must get address from the handle
	hz = RelConnHandle(nCtx)
    conns = conns - 1
	dim a$
	//rc = BleAdvertStart(0,a$,25,300000,0)
	//AssertResCode(rc)
    print "\nDisconnected\n";pr$

  case BLE_EVBLEMSGID_DISPLAY_PASSKEY
    print "Display Pairing Passkey ";nCtx

  case BLE_EVBLEMSGID_NEW_BOND
    //DbgMsg(" +++ New Bond")

  case BLE_EVBLEMSGID_UPDATED_BOND
    print " +++ Updated Bond"

  case BLE_EVBLEMSGID_ENCRYPTED
    //DbgMsg(" +++ Encrypted Connection")

  case BLE_EVBLEMSGID_CONN_TO_BONDED_MASTER
    //DbgMsgVal(" -- Conn to Bonded Master ",nCtx)

  case BLE_EVBLEMSGID_AUTH_KEY_REQUEST
    print " +++ Auth Key Request, type=";nCtx

  case BLE_EVBLEMSGID_CONN_PARMS_UPDATE
    //ShowConnParms(nCtx)

  case BLE_EVBLEMSGID_CONN_PARMS_UPDATE_FAIL
    print " ??? Conn Parm Negotiation FAILED"

  case else
    print "Unknown Ble Msg"; nMsgId
  endselect
endfunc 1
//==============================================================================
// This handler is called when a BLE primary service is discovered
//==============================================================================
function HandlerPrimSvc(hConn,hUuid,hStart,hEnd) as integer

	sAttr = hStart
	eAttr = hEnd
	if hUuid != 0 then
		if command == BLUEZ_COMMAND_GATTTOOL_PRIMARY then
			print "\n" 
			print "attr handle = 0x";integer.h' hStart
			print ", end grp handle = 0x";integer.h' hEnd
			print ", uuid = ";integer.h' hUuid
			rc = BleDiscServiceNext(hConn)
	
	
	
		elseif command == BLUEZ_COMMAND_GATTTOOL_CHARACTERISTICS then
			rc = BleDiscCharFirst(hConn,0,sAttr,eAttr)
		
		endif
		
	else
		BleGattcClose()
		print "\n";pr$
		exitfunc 1
		
	endif
	
	
endfunc 1
//==============================================================================
// This handler is called when a BLE characteristic is discovered
//==============================================================================
function HandlerCharDisc(hConn,hUuid,cProp,hVal,hiUuid) as integer
	
	if hUuid != 0 then
		print "\n"
		print "handle = 0x";integer.h' hVal-1
		print ", char properties = 0x";integer.h' cProp
		print ", char value handle = 0x";integer.h' hVal
		print ", uuid = ";integer.h' hUuid
	endif
	
	rc = BleDiscCharNext(hConn)
	if rc != 0 then
		rc = BleDiscServiceNext(hConn)
		if rc !=0 then
			print "\n";pr$
			BleGattcClose()
		endif
	endif
	
endfunc 1
//==============================================================================
// This handler is called when a BLE descriptor is discovered
//==============================================================================
function HandlerDescDisc(hChar, hUuid, hDisc) as integer
	
	if hUuid !=0 then
		print "\n"
		print "handle : 0x";integer.h' hDisc;" uuid : ";integer.h' hUuid
	endif
	
	rc = BleDiscDescNext(hChar)
	if rc !=0 then
		print "\n";pr$
		BleGattcClose()
	endif
	
endfunc 1
//==============================================================================
// This handler is called when a BLE characteristic attribute has been read
//==============================================================================
function HandlerAttrRead(hConn,hAttr,nSts) as integer

	dim a$,ofst  
	if nSts == 0 then
		rc = BleGattcReadData(hConn,valHdl,ofst,a$)
		if rc==0 then
			print "\nCharacteristic value/descriptor: "
			print "";StrHexize$(a$)
			print " (";StrEscape$(a$);") \n";pr$
		else	
			AssertResCode(rc)
		endif
	 
	else 
		rc = _gattStatus(nSts)
	endif
	
	BleGattcClose()
	
endfunc 1
//==============================================================================
// This handler is called when a BLE characteristic attribute has been written to 
//==============================================================================
function HandlerAttrWrite(hConn,aHndl,nSts) as integer
    
	if nSts == 0 then
		print "\nCharacteristic value was written successfully\n";pr$
	
	else 
		rc = _gattStatus(nSts)
	
	endif
	
endfunc 1
//==============================================================================
// This handler is called when there is data notified or indicated
//==============================================================================
function HandlerAttrNtfyCmd() as integer
  
	dim hConn,hAttr,att$,dscd
  
	if gattLsn == 1 then
		do
			rc=BleGattcNotifyRead(hConn,hAttr,att$,dscd)
			if rc==0 then
				print "\nNotification/Indication handle = ";integer.h hAttr;" value: ";StrHexize$(att$)
			endif
		dowhile rc==0
	endif

endfunc 1

//==============================================================================
// Called when data is received via UART when bridged to SPP
//==============================================================================
function HandlerUartRxSpp()
    dim uLen, u$, nLen, nLen2 : uLen = 1
    WHILE uLen != 0
        //read data that has arrived through via the UART
        uLen = UartRead(u$)
        if uLen > 0 then
			
			if uLen == 4 then
			// Check if received ^^^ in Line mode
				dim i$, j$
				i$ = u$
				rc = ExtractStrToken(i$,j$)
				if strcmp(j$,"^^^")==0 then 
					rc = BtcSppDisconnect(hcSpp)
					AssertResCode(rc)
				endif 
				STRSHIFTLEFT(u$, nLen)
				
            elseif StrCmp(u$,"^")==0 then
				carCnt = carCnt + 1
				if carCnt<3 then
					exitfunc 1
				else
					carCnt = 0
					rc = BtcSppDisconnect(hcSpp)
					AssertResCode(rc)
				endif
            
			else
				carCnt = 0
                //write data to most recent spp connection
                nLen2 = 0
                WHILE nLen2 != uLen
                    rc = BtcSPPWrite(hcSpp, u$, nLen)
                    IF rc != 0 THEN
                        //Assume problem with the SPP connection
                        exitfunc rc
                    ENDIF
                    STRSHIFTLEFT(u$, nLen)
                    nLen2 = nLen2 + nLen
                ENDWHILE
            endif
        endif
    ENDWHILE
endfunc 1
//==============================================================================
// This handler is called when data has arrived at the serial port
//==============================================================================
function HandlerUartRxLsn() as integer
	dim nMatch
	
	nMatch=UartReadMatch(stRsp$,13)
	if nMatch!=0 then
		//CR exists in the input buffer
		urtcmd$ = strsplitleft$(stRsp$, nMatch)
		tlen = ExtractStrToken(urtcmd$,tkn$)
		if strcmp(tkn$,"stop")==0 then 
			gattLsn = 0
			print pr$
			rc = SendMsgApp(0, NORMAL_MODE)
		endif
	endif
endfunc 1
//==============================================================================
// This handler is called when data has arrived at the serial port
//==============================================================================
function HandlerUartRxCmd() as integer
	dim nMatch
	
	nMatch=UartReadMatch(stRsp$,13)
	if nMatch!=0 then
		//CR exists in the input buffer
		urtcmd$ = strsplitleft$(stRsp$, nMatch)
		exitfunc OnUartCmd()
	endif
endfunc 1
'//==============================================================================
'// Called after SendMsgApp is called. Used to switch between command and bridge mode
'//==============================================================================
function SetMode(msgID, cmd) as integer
	if cmd == NORMAL_MODE then
		OnEvent	 EVUARTRX					call HandlerUartRxCmd
		carCnt=0
	elseif cmd == RFCOMM_MODE then
		OnEvent	EVUARTRX					call HandlerUartRxSpp
		
	elseif cmd == GATTTOOL_LISTEN then	
		print "\nListening for notifications/indications. For hangup, type \22stop\22\n"
		OnEvent	EVUARTRX					call HandlerUartRxLsn

	endif
endfunc 1
//******************************************************************************

//******************************************************************************
// Equivalent to main() in C
//******************************************************************************

//------------------------------------------------------------------------------
// Enable synchronous event handlers
//------------------------------------------------------------------------------
// uart related events
OnEvent  EVUARTRX					call HandlerUartRxCmd

// hcitool related events (BTC)
OnEvent EVINQRESP					call HandlerInqResp
OnEvent	EVBTC_INQUIRY_TIMEOUT		call HandlerBtcInqTimOut	
OnEvent EVBTC_DISCOV_TIMEOUT		call HandlerBtcDiscTimOut

// rfcomm related events
OnEvent  EVSPPCONN                	call HandlerSppCon
OnEvent  EVBTC_SPP_CONN_TIMEOUT   	call HandlerSppConnTimOut
OnEvent  EVSPPDISCON              	call HandlerSppDiscon
OnEvent  EVBTC_SPP_DATA_RECEIVED  	call HandlerSppData

// hcitool related events (BTC)
OnEvent  EVBTC_PAIR_REQUEST       	call HandlerPairReq
OnEvent  EVBTC_PIN_REQUEST        	call HandlerPinReq
OnEvent  EVBTC_PAIR_RESULT        	call HandlerPairRes

// hcitool related events (BLE)
OnEvent EVBLE_ADV_REPORT			call HandlerAdvRpt
OnEvent  EVBLE_SCAN_TIMEOUT       	call HandlerBlrScanTimOut
OnEvent	EVBLE_CONN_TIMEOUT			call HandlerBleConnTimOut
OnEvent  EVBLEMSG                 	call HandlerBleMsg
OnEvent	EVBLE_ADV_TIMEOUT			call HandlerBleAdvTimOut
//OnEvent EvDiscon                    call HndlrDiscon

// gatttool related events
OnEvent  EVDISCPRIMSVC            	call HandlerPrimSvc
OnEvent  EVDISCCHAR               	call HandlerCharDisc
OnEvent  EVDISCDESC               	call HandlerDescDisc
OnEvent  EVATTRREAD 				call HandlerAttrRead
OnEvent  EVATTRWRITE              	call HandlerAttrWrite


// Called for rfcomm connect and hangup
OnEvent  EVMSGAPP                 call SetMode
OnEvent	EVATTRNOTIFY             	call HandlerAttrNtfyCmd


//==============================================================================
//==============================================================================
sub Initialise()
	InitBtDevice()
	InitConnHandles()
	
	print "\n-----------------------\n"
	print " CMDZ MANAGER v";mjVersion;".";mnVersion;"\n"
	print "-----------------------\n"
	print "\nType \22help\22 or \22<command> help\22\n"
	print pr$
	
endsub
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
Initialise()


//------------------------------------------------------------------------------
// Wait for a synchronous event.
// An application can have multiple <WaitEvent> statements
//------------------------------------------------------------------------------
WaitEvent