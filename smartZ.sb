//******************************************************************************
// Laird Technologies (c) 2014
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++                                                                      ++
// +++++  When UwTerminal downloads the app it will store it as a filenname   ++
// +++++  which consists of all characters up to the first . and excluding it ++
// +++++                                                                      ++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//	smartZ.manager
//
//
//	This app provides for a command interface to the BT900 devkit over the UART. The
// 	commands are designed to mimic the behaviour of BlueZ commands used in Linux.
//
//	When you run the app you will get a -------> command prompt to allow you to submit
//	commands as follows:- 
//
//
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//		hcitool dev 		Display local devices
//		hcitool inq 		Inquire remote devices
//		hcitool scan		Scan for remote devices
//		hcitool name		Get name from remote device
//		hcitool con 		Display active connections
//		hcitool pair		Pair with remote device
//		hcitool unpair  	Unpair from remote device
//		hcitool leadv		Start LE advertisement
//		hcitool noleadv		Stop LE advertisement
//		hcitool lescan      Start LE scan
//		hcitool lecc        Create a LE Connection
//		hcitool ledc        Disconnect a LE Connection
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//		rfcomm connect <bdaddr>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//		gatttool 
//		gatttool --primary        	Primary Service Discovery
//		gatttool --characteristics	Characteristics Discovery
//		gatttool --char-read      	Characteristics Value/Descriptor Read
//		gatttool --char-write    	Characteristics Value Write Without Response
//		gatttool --char-desc     	Characteristics Descriptor Discovery
//		gatttool --listen        	Listen for notifications and indications
//
//		Options:
//		-b, --device=MAC	Specify remote Bluetooth address
//		-l, --sec-level		Set security level. Default: low
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//		hciconfig auth  				Enable Authentication
//		hciconfig noauth				Disable Authentication
//		hciconfig piscan				Enable Page and Inquiry scan
//		hciconfig noscan				Disable scan
//		hciconfig iscan 				Enable Inquiry scan
//		hciconfig pscan 				Enable Page scan
//		hciconfig name   	[name]		Get/Set local name
//		hciconfig inqmode	[mode]		Get/Set inquiry mode
//		hciconfig inqtype	[type]		Get/Set inquiry scan type
//		hciconfig inqtpl	[level]		Get/Set inquiry transmit power level
//		hciconfig letpl		[level]		Get/Set LE transmit power level
//		hciconfig sspmode	[mode]		Get/Set Simple Pairing Mode
//		hciconfig putkey	<bdaddr>	Store link key on the device
//		hciconfig delkey	<bdaddr>	Delete link key from the device
//		hciconfig version				Display version information
//		hciconfig leadv  				Enable LE advertising
//		hciconfig noleadv				Disable LE advertising
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//******************************************************************************
// Definitions
//******************************************************************************

        // Number of connections
#define NUM_OF_CONNS                         8

// BLE EVENT MSG IDs
#define BLE_EVBLEMSGID_CONNECT                          0 // msgCtx = connection handle
#define BLE_EVBLEMSGID_DISCONNECT                       1 // msgCtx = connection handle
#define BLE_EVBLEMSGID_SERVICE_ERROR                    4 // msgCtx = resultcode
#define BLE_EVBLEMSGID_DISPLAY_PASSKEY                  9 // msgCtx = passcode to display
#define BLE_EVBLEMSGID_NEW_BOND                        10 // msgCtx = connection handle
#define BLE_EVBLEMSGID_AUTH_KEY_REQUEST                11 // msgCtx = 1 for passkey, 2 for 16 byte OOB data

// #define FUTURE_USE                                   13
#define BLE_EVBLEMSGID_CONN_TO_BONDED_MASTER           16 // msgCtx = connection handle
#define BLE_EVBLEMSGID_UPDATED_BOND                    17 // msgCtx = connection handle
#define BLE_EVBLEMSGID_ENCRYPTED                       18 // msgCtx = connection handle
#define BLE_EVBLEMSGID_POWER_FAILURE_WARNING           19 // msgCtx = current supply voltage
#define BLE_EVBLEMSGID_UNENCRYPTED                     20 // msgCtx = connection handle
#define BLE_EVBLEMSGID_DEVICENAME_WRITE                21 // msgCtx = connection handle 

// SMARTZ COMMAND IDs: HCITOOL
#define SMARTZ_COMMAND_HCITOOL_DEV						1
#define SMARTZ_COMMAND_HCITOOL_INQ						2
#define SMARTZ_COMMAND_HCITOOL_SCAN						3
#define SMARTZ_COMMAND_HCITOOL_NAME						4
#define SMARTZ_COMMAND_HCITOOL_CON						5
#define SMARTZ_COMMAND_HCITOOL_PAIR						6
#define SMARTZ_COMMAND_HCITOOL_UNPAIR					7
#define SMARTZ_COMMAND_HCITOOL_LESCAN					8
#define SMARTZ_COMMAND_HCITOOL_LEADV						9
#define SMARTZ_COMMAND_HCITOOL_LENOADV					10
#define SMARTZ_COMMAND_HCITOOL_LECC						11
#define SMARTZ_COMMAND_HCITOOL_LEDC						12

// SMARTZ COMMAND IDs: GATTTOOL
#define SMARTZ_COMMAND_GATTTOOL_PRIMARY					21
#define SMARTZ_COMMAND_GATTTOOL_CHARACTERISTICS			22
#define SMARTZ_COMMAND_GATTTOOL_CHAR_READ				23
#define SMARTZ_COMMAND_GATTTOOL_CHAR_WRITE				24
#define SMARTZ_COMMAND_GATTTOOL_CHAR_DESC				25
#define SMARTZ_COMMAND_GATTTOOL_LISTEN					26

// SMARTZ COMMAND IDs: RFCOMM
#define SMARTZ_COMMAND_RFCOMM_CONNECT					31

// APP RUN MODES
#define NORMAL_MODE                                 	0
#define RFCOMM_MODE                          			1
#define GATTTOOL_LISTEN									2

//******************************************************************************
// Global Variable Declarations
//******************************************************************************
dim rc
dim stRsp$ 			        	//Uart rx data is stored here
dim ok$,er$,pr$
dim urtcmd$                 	// cmd line from uart
dim tkn$,tlen               	// used by command parser
dim hc[NUM_OF_CONNS+1]      	// contains connection handles
dim conns                   	// number of connections
dim name$						// local device name
dim addr$						// address of device being connected to

dim prAddr$              		// BT address of last device pairing requested from or initiated with
dim hcSpp                   	// handle of connection to use for VSP service

dim command : command = 0		// Currently active smartZ command
dim nDiscv : nDiscv = 1			// The device is discoverable by default
dim nConn : nConn = 1 			// The device is connectable by default
dim nPair : nPair = 1			// The device is pairable by default					
dim inqtype	: inqtype = 0		// Inquiry Type: 0 General, 1 Limited
dim inqmode	: inqmode = 2		// Inquiry Mode: 0 for Standard, 1 for with RSSI, 2 for Extended)
dim sspmode : sspmode = 1		// SSP Mode: 0 for disabled, 1 for enabled 
dim inqtpl : inqtpl=4			// Inquiry transmit power level
dim letpl : letpl = 4			// LE Tx Power level in dBm
dim gattLsn : gattLsn = 0		// If Lsn = 1, notifications will be shown

dim mjVersion : mjVersion=0		// Major version number
dim mnVersion : mnVersion=98	// Minor version number
dim conHdl						// global connection handle of the current connection being serviced
dim chrHdl						// global characteristic handle of the current characteristic being serviced
dim valHdl						// global characteristic value handle of the current characteristic value handle being serviced

dim carCnt                  	//count variable for number of times '^' entered
dim secPair						// If 1, it means sec-level is medium or high and therefore should pair

//******************************************************************************
// Initialise Global Variable
//******************************************************************************

ok$    = "\nOK"
er$    = "\nERROR "
pr$    = "------->"

//==============================================================================
//==============================================================================
sub AssertResCode(resCode)
	if rc !=0 then
		print "error: ";integer.h' rc;"\n"
	endif
endsub 
//==============================================================================
//==============================================================================
sub delay(t as integer)

		t = t*1000
		DIM tm
		tm = gettickcount()
		while (gettickcount()-tm) < t
			//wait for t*1000 milliseconds
		endwhile
		
endsub
//==============================================================================
// Initialise all connection handles
//==============================================================================
sub InitConnHandles()

	dim z
	for z=0 to (NUM_OF_CONNS)
		hc[z]=-1
	next

endsub
//==============================================================================
// Add the connection handle to the list of connection handles
//==============================================================================
function AcqConnHandle(hConn)

	dim z
	for z=1 to (NUM_OF_CONNS)
		if hc[z] == -1 then
			hc[z]=hConn
			exitfunc z
		endif
	next

endfunc 0
//==============================================================================
// Release the connection handle from the array of conn handles
//==============================================================================
function RelConnHandle(hConn)

	dim z
	for z=1 to (NUM_OF_CONNS)
		if hc[z] == hConn then 
			hc[z]=-1
			exitfunc z
		endif
	next

endfunc 0
//------------------------------------------------------------------------------
//** #include the correct library file for the smartBASIC module being used 
//------------------------------------------------------------------------------
#include "lib\cmd.bluez.manager.sblib"

//==============================================================================
// Initialise the Bluetooth device
// Set the device to be disoverable, connectable, pairable, 
// Set the inquiry type to be general, inquiry mode to be extended
//==============================================================================
sub InitBtDevice()

	dim nHandle
	
	// Set the name of the local Bluetooth device
	name$ = SYSINFO$(4)
	name$ = right$(name$, 6)
	name$ = StrHexize$(name$)
	name$ = "smartZ-" + name$
	rc = BTCSETFRIENDLYNAME (name$)
	AssertResCode(rc)

	// Configure classic BT radio
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Set device is discoverable with 300s discoverability timeout
	rc = BtcSetDiscoverable(1, 300)
	AssertResCode(rc)
	// Set device to be connectable
	rc = BtcSetConnectable(1)
	AssertResCode(rc)
	// Set the device to be pairable
	rc = BtcSetPairable(1)
	AssertResCode(rc)															
	// Set inquiry type to be general
	rc = BtcInquiryConfig(0, inqtype)
	AssertResCode(rc)
	// Set inquiry mode to be extended
	rc = BtcInquiryConfig(1, inqmode)
	AssertResCode(rc)
	// Open Spp
	rc = btcSppOpen(nHandle)
	AssertResCode(rc)
	sspmode = 1

endsub											
//==============================================================================
// Print the Help menu
//==============================================================================
sub _help()

	print "Available Commands: \n\n"
	print "	help\n"
	print "	hcitool\n"
	print "	gatttool\n"
	print "	rfcomm\n"
	print "	hciconfig\n"
	print "	quit/exit\n"
	print "\n"
	print "For more information on the usage of each command use:\n"
	print "<command> --help\n\n"

endsub
//==============================================================================
// print the hcitool help menu
//==============================================================================
sub _hciHelp()

	print "Usage:\n"
	print "	hcitool <command> [command parameters]\n\n"
	print "Commands:\n"
	print "	dev 		Display local devices\n"
	print "	inq 		Inquire remote devices\n"
	print "	scan		Scan for remote devices\n"
	print "	name		Get name from remote device\n"
	print "	con 		Display active connection handles\n"
	print "	pair		Pair with remote device\n"
	print "	unpair  	Unpair from remote device\n"
	print "	leadv		Start LE advertisement\n"
	print "	noleadv 	Stop LE advertisement\n"
	print "	lescan      Start LE scan\n"
	print "	lecc        Create a LE Connection\n"
	print "	ledc        Disconnect a LE Connection\n"
	print "\n"
	print "For more information on the usage of each command use:\n"
	print "	hcitool <command> --help\n\n"
	
endsub
//==============================================================================
// Print the gatt help menu
//==============================================================================
sub _gattHelp()

	print "Usage:\n"
	print "	gatttool [OPTION...] <command>\n\n"
	print "GATT commands\n"
	print "	--primary        						Primary Service Discovery\n"
	print "	--characteristics						Characteristics Discovery\n"
	print "	--char-read      						Characteristics Value/Descriptor Read\n"
	print "	--char-write    						Characteristics Value Write Without Response\n"
	print "	--char-desc     						Characteristics Descriptor Discovery\n"
	print "	--listen        						Listen for notifications and indications\n"
	print "\n"
	print "Options:\n"
	print "	-b, --device=MAC						Specify remote Bluetooth address\n"
	print "	-l, --sec-level=[low | medium | high]		Set security level. Default: low\n"	
	print "\nFor more information on the usage of each command use:\n"
	print "	gatttool <command> --help\n\n"

endsub
//==============================================================================
// Print the hciconfig help menu
//==============================================================================
sub _hciCfgHelp()

	print "Usage:\n"
	print "	hciconfig <command> [command parameters]\n\n"
	print "Commands:\n"
	print "	auth  				Enable Authentication\n"
	print "	noauth				Disable Authentication\n"
	print "	piscan				Enable Page and Inquiry scan\n"
	print "	noscan				Disable scan\n"
	print "	iscan 				Enable Inquiry scan\n"
	print "	pscan 				Enable Page scan\n"
	print "	name   	[name]		Get/Set local name\n"
	print "	inqtpl	[level]		Get/Set inquiry transmit power level\n"
	print "	inqmode	[mode]		Get/Set inquiry mode\n"
	print "	inqtype	[type]		Get/Set inquiry scan type\n"
	print "	sspmode	[mode]		Get/Set Simple Pairing Mode\n"
	print "	putkey	<bdaddr>		Store link key on the device\n"
	print "	delkey	<bdaddr>		Delete link key from the device\n"
	print "	version				Display version information\n"
	print "	leadv  				Enable LE advertising\n"
	print "	noleadv				Disable LE advertising\n"
	print "	letpl		[level]		Get/Set LE transmit power level\n"
	print "\n"

endsub
//==============================================================================
// Print the rfcomm help menu
//==============================================================================
sub _rfcommHelp()

	print "Usage:\n"
	print "		rfcomm connect <bdaddr>\n"

endsub
//==============================================================================
// Extract the hcitool command
//==============================================================================
sub _hci()

	while ExtractStrToken(urtcmd$, tkn$)!=0
		if strcmp(tkn$,"help")==0 then
			_hciHelp()
			break

		elseif strcmp(tkn$,"dev")==0 then
			// Display the address of the local device
			rc = _hciDev()								

		elseif strcmp(tkn$,"inq")==0 then				
			command = SMARTZ_COMMAND_HCITOOL_INQ
			// Inquire for remote devices (show address only)
			rc = _hciInq()							

		elseif strcmp(tkn$,"scan")==0 then
			// Scan for remote devices (show address and name)
			command = SMARTZ_COMMAND_HCITOOL_SCAN
			rc = _hciScan()							

		elseif strcmp(tkn$,"name")==0 then
			// Get name from remote device
			command = SMARTZ_COMMAND_HCITOOL_NAME
			rc = _hciName()							

		elseif strcmp(tkn$,"con")==0 then
			// Display active connection handles
			command = SMARTZ_COMMAND_HCITOOL_CON
			rc = _hciCon()							

		elseif strcmp(tkn$, "pair")==0 then
			// Create connection to remote device
			command = SMARTZ_COMMAND_HCITOOL_PAIR
			rc = _hciPair()

		elseif strcmp(tkn$, "unpair")==0 then
			// Disconnect from remote device
			command = SMARTZ_COMMAND_HCITOOL_UNPAIR
			rc = _hciUnpair()

		elseif strcmp(tkn$, "leadv")== 0 then
			// LE advertise
			rc = _hciLeAdv()
		
		
		elseif strcmp(tkn$, "noleadv")== 0 then
			// LE advertise
			rc = _hciNoLeAdv()
		
	
		elseif strcmp(tkn$, "lescan")==0 then
			// Start LE scan
			rc = _hciLeScan()

		elseif strcmp(tkn$, "lecc")==0 then
			// Create a LE connection
			rc = _hciLeCc()

		elseif strcmp(tkn$, "ledc")==0 then
			// Disconnect a LE Connection
			rc = _hciLeDc()
		
		endif
	endwhile

endsub
//==============================================================================
// Extract the gatttool command
//==============================================================================
sub _gatt()

	dim s$
	s$ = urtcmd$
	while ExtractStrToken(s$, tkn$)!= 0
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		if strcmp(tkn$,"help")==0 then
			_gattHelp()
			break

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		elseif strcmp(tkn$,"primary")==0 then
			command = SMARTZ_COMMAND_GATTTOOL_PRIMARY
			rc = _gattPrimary()
			break

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		elseif strcmp(tkn$,"characteristics")==0 then
			command = SMARTZ_COMMAND_GATTTOOL_CHARACTERISTICS
			rc = _gattChar()
			break

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		elseif strcmp(tkn$, "char")==0 then 
			strshiftleft(s$, 1)
			rc = ExtractStrToken(s$, tkn$)
			if strcmp(tkn$, "read")==0 then
				command = SMARTZ_COMMAND_GATTTOOL_CHAR_READ
				rc = _gattCharRead()
				break
			elseif strcmp(tkn$, "write")==0 then
				command = SMARTZ_COMMAND_GATTTOOL_CHAR_WRITE
				rc = _gattCharWrite()
				break
			elseif strcmp(tkn$, "desc")==0 then
				command = SMARTZ_COMMAND_GATTTOOL_CHAR_DESC
				rc = _gattCharDesc()
				break
			endif
		
		endif
	endwhile

endsub
//==============================================================================
// Extract the hciconfig command
//==============================================================================
sub _hciCfg()

	dim s$, val
	s$ = urtcmd$
	while ExtractStrToken(s$, tkn$)!= 0
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		if strcmp(tkn$,"help")==0 then
			_hciCfgHelp()
			break

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		elseif strcmp(tkn$,"auth")==0 then 
			rc = BtcSetConnectable(1)
			AssertResCode(rc)
			rc = BtcSetPairable(1)
			AssertResCode(rc)
	
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~		
		elseif strcmp(tkn$,"noauth")==0 then
			rc = BtcSetPairable(0)
			AssertResCode(rc)

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		elseif strcmp(tkn$,"name")==0 then 
			tlen = ExtractStrToken(s$,tkn$)
			if tlen == 0 then
				rc = BtcGetFriendlyName(s$)
				AssertResCode(rc)
				print s$;"\n"
			
			else
				DIM len
				name$ = tkn$ + s$
				len = strlen(name$)
				name$ = left$(name$, len-1)
				rc = BtcSetFriendlyName(name$)
				AssertResCode(rc)
				exitsub
			endif

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		elseif strcmp(tkn$,"piscan")==0 then 
			//Enable inquiry scan and page scan (default)
			nDiscv = 1 
			rc = BtcSetDiscoverable(nDiscv, 300)
			AssertResCode(rc)
			rc = BtcSetConnectable(nConn)
			AssertResCode(rc)

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		elseif strcmp(tkn$,"pscan")==0 then 
			//Enable page scan
			nDiscv = 1 
			rc = BtcSetDiscoverable(nDiscv, 300)
			AssertResCode(rc)

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		elseif strcmp(tkn$,"iscan")==0 then 
			//Enable inquiry scan
			nDiscv = 1
			rc = BtcSetDiscoverable(nDiscv, 300)
			AssertResCode(rc)

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		elseif strcmp(tkn$,"noscan")==0 then 
			//The adapter in not detectable by other devices and will not accept any incoming connections
			nDiscv = 0 
			rc = BtcSetDiscoverable(nDiscv, 300)
			AssertResCode(rc)
			rc = BtcSetConnectable(nConn)
			AssertResCode(rc)
	
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		elseif strcmp(tkn$, "inqtpl")==0 then
			// Get/set the transmit power level
			if ExtractStrToken(s$, tkn$) == 0  then
				// Get the transmit power level
				print "Inquiry transmit power level : ";inqtpl;"\n"
			else 
				// Set the transmit power level
				if strcmp(tkn$,"-")==0 then
					rc = ExtractStrToken(s$, tkn$)
					val = StrValDec(tkn$)
					if (val > 70) then
						print "Invalid power value. Valid range is from -70 to 20 dBm\n"
					else
						inqtpl = val*-1
					endif
				else
					val = StrValDec(tkn$)
					if (val > 20) then
						print "Invalid power value. Valid range is from -70 to 20 dBm\n"
					else
						inqtpl =  val
					endif
				endif
				rc = BtcInquiryConfig(3,inqtpl)
				AssertResCode(rc)
			endif
	
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		elseif strcmp(tkn$,"inqmode")==0 then 
			//Get/Set Inquiry mode
			if ExtractStrToken(s$, tkn$) == 0  then
				// Get inquiry mode
				if inqmode == 0 then
					print "Inquiry mode: Standard Inquiry\n"
				elseif inqmode == 1 then
					print "Inquiry mode: Inquiry with RSSI\n"
				elseif inqmode == 2 then
					print "Inquiry mode: Inquiry with RSSI or Extended Inquiry\n"
				else
					print "Invalid inquiry mode detected. Please set inquiry mode to 0, 1, or 2\n"
				endif
			else
				val = StrValDec(tkn$)
				if val >= 0 && val < 3 then
					inqmode = val
					rc = BtcInquiryConfig(1, inqmode)
					AssertResCode(rc)
				else 
					print "Invalid inquiry mode. Valid values are 0, 1, and 2\n"
				endif
			endif
	
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		elseif strcmp(tkn$,"inqtype")==0 then 
			//Get/Set Inquiry type
			if ExtractStrToken(s$, tkn$) == 0  then
				// Get inquiry type
				if inqtype == 0 then
					print "Inquiry scan type: General Inquiry Scan\n"
				elseif inqtype == 1 then
					print "Inquiry scan type: Limited Inquiry Scan\n"
				else
					print "Invalid inquiry type detected. Please set inquiry type to 0, or 1\n"
				endif
			else
				val = StrValDec(tkn$)
				if val >= 0 && val < 2 then
					inqtype = val
					rc = BtcInquiryConfig(0, inqtype)
					AssertResCode(rc)
				else 
					print "Invalid inquiry type. Valid values are 0 and 1\n"
				endif
			endif

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		elseif strcmp(tkn$, "sspmode")==0 then
			// Get/Set Simple Pairing Mode
			if ExtractStrToken(s$, tkn$) == 0  then
			// Get Simple Pairing Mode
				print "Simple Pairing Mode: "
				if sspmode == 0 then 
					print "Disabled\n"
				else 
					print "Enabled\n"
				endif
			else
				dim hn
				val = StrValDec(tkn$)
				if val == 0 then
					rc = BtcSppClose(hn)
					AssertResCode(rc)
					sspmode = 0
				elseif val == 1 then
					rc = BtcSppOpen(hn)
					AssertResCode(rc)
					sspmode = 1
				else
					print "Invalid ssp mode. Valid values are 0 and 1\n"
				endif
			endif

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		elseif strcmp(tkn$, "putkey")==0 then
			//store link key on the device
			if ExtractStrToken(s$, tkn$) == 0 then
				print "MAC address not supplied\n"
			else
				tkn$ = strdehexize$(tkn$)
				rc = BtcBondingPersistKey(tkn$)
				AssertResCode(rc)
				if rc == 0 then
					print "Link key made persistent\n"
				endif
			endif

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		elseif strcmp(tkn$, "delkey")==0 then
			//delete link key on the device
			if ExtractStrToken(s$, tkn$) == 0 then
				print "MAC address not supplied\n"
			else
				tkn$ = strdehexize$(tkn$)
				rc = BtcBondingEraseKey(tkn$)
				AssertResCode(rc)
				if rc == 0 then
					print "Link key erased\n"
				endif
			endif

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		elseif strcmp(tkn$, "leadv")==0 then
			dim a$
			rc = BleAdvertStart(0,a$,25,0,0)
			AssertResCode(rc)

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		elseif strcmp(tkn$, "noleadv")==0 then
			rc = BleAdvertStop()
			AssertResCode(rc)

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		elseif strcmp(tkn$, "letpl")==0 then
			// Get/set the LE transmit power level
			if ExtractStrToken(s$, tkn$) == 0  then
				// Get the LE transmit power level
				print "LE transmit power level : ";letpl;"\n"
			else 
				// Set the LE transmit power level
				if strcmp(tkn$,"-")==0 then
					rc = ExtractStrToken(s$, tkn$)
					val = StrValDec(tkn$)
					if (val > 20) then
						print "Invalid power value. Valid range is from -20 to 8 dBm\n"
					else
						letpl = val*-1
					endif
				else
					val = StrValDec(tkn$)
					if (val > 8) then
						print "Invalid power value. Valid range is from -20 to 8 dBm\n"
					else
						letpl =  val
					endif
				endif
				rc = BleTxPowerSet(letpl)
				AssertResCode(rc)
			endif

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		elseif strcmp(tkn$, "version")==0 then
			dim fw, X, Y, Z
			fw = SYSINFO(3)
			X = (fw >> 24) & 0xFF
			Y = (fw >>  8) & 0xFFFF
			Z = (fw      ) & 0xFF
			print "\nApp Version: smartZ Version ";mjVersion;".";mnVersion;"\n"
			print "Device Name: ";BleGetDeviceName$();"\n"
			print "Firmware: 9.";X;".";Y;".";Z;"\n"
			print "Manufacturer: Laird Technologies\n"

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

		endif
	endwhile

endsub
//==============================================================================
// Extract the rfcomm command
//==============================================================================
sub _rfcomm()

	while ExtractStrToken(urtcmd$, tkn$)!= 0
		if strcmp(tkn$, "help")==0 then
			_rfcommHelp()
			break

		elseif strcmp(tkn$, "connect")==0 then
			command = SMARTZ_COMMAND_RFCOMM_CONNECT
			rc = _rfcommConnect()

		endif
	endwhile

endsub
//==============================================================================
// Extract the received Uart command
//==============================================================================
function OnUartCmd() as integer

	// get first token
	tlen = ExtractStrToken(urtcmd$,tkn$) 

	if strcmp(tkn$,"hcitool")==0 then
		_hci()

    elseif strcmp(tkn$,"gatttool")==0 then
		_gatt()

	elseif strcmp(tkn$,"hciconfig")==0 then
		_hciCfg()

	elseif strcmp(tkn$, "rfcomm")==0 then
		_rfcomm()

	elseif strcmp(tkn$, "help")==0 then
		_help()

	elseif strcmp(tkn$,"exit")==0 || strcmp(tkn$,"quit")==0  then
		reset(0)

	elseif strcmp(tkn$,"")==0 then
		//received carriage return. Do nothing

	else
		print tkn$;": command not found\n"
	endif

	print pr$

endfunc 1
//==============================================================================
// gatt status error codes
//==============================================================================
sub _gattStatus(status as integer)

	print "\nATT Error: "
	select status

		case H'0101
			print "Invalid attribute handle\n"
	
		case H'0102
			print "Read not permitted\n"

		case H'0103
			print "Write not permitted\n"

		case H'0104
			print "Used in ATT as invalid PDU\n"
	
		case H'0105
			print "Authenticated link required\n"

		case H'0106
			print "Used in ATT as request not supported\n"

		case H'0107
			print "Offset specified was past the end of the attribute\n"

		case H'0108
			print "Used in ATT as insufficient authorisation\n"

		case H'0109
			print "Used in ATT as prepare queue full\n"

		case H'010A
			print "Used in ATT as attribute not found\n"

		case H'010B
			print "Attribute cannot be read or written using read/write requests\n"

		case H'010C
			print "Encryption key size used is insufficient\n"

		case H'010D
			print "Invalid value size\n"

		case H'010E
			print "Very unlikely error\n"

		case H'010F
			print "Encrypted link required\n"

		case H'0110
			print "Attribute type is not a supported grouping attribute\n"

		case H'0111
			print "Encrypted link required\n"

		case H'0180
			print "Application range begin\n"

		case H'019F
			print "Application range end\n"

		case H'01FE
			print "Profile and service error: Procedure already in progress\n"

		case H'01FF
			print "Profile and service error: Out of range\n"

		case else
			print "Unknown status\n"

		endselect
	print pr$

endsub
//******************************************************************************
// Handler definitions
//******************************************************************************

//==============================================================================
// This handler is called when there is an inquiry report waiting to be read 
// Algorithm will prevent display of data from the same peer consecutively 
//==============================================================================
function HandlerInqResp(respType) as integer

	dim ad$,dta$,ndx,rsi,tag, name$

	// Get the report from the inquiry response
	rc = BtcInquiryGetReport(ad$,dta$,ndx,rsi)

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if command == SMARTZ_COMMAND_HCITOOL_INQ then
		print "\n		"; StrHexize$(ad$)

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	elseif command == SMARTZ_COMMAND_HCITOOL_SCAN then
		print "\n		"; StrHexize$(ad$)
		if respType == 2 then
			//Get local name
			tag = 0x09
			rc=BtcGetEIRbyTag(dta$, tag, name$)
			if rc == 0x5703 then
				tag = 0x08
				rc=BtcGetEIRbyTag(dta$, tag, name$)

			endif

			if rc == 0 then
				print "  ";name$
			endif		
		else
			print "  n/a"
		endif

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	elseif command == SMARTZ_COMMAND_HCITOOL_NAME then
		// Only looking for name of specified address
		if strcmp(ad$, addr$)!=0 then
			exitfunc 1

		else
			print "\n		"; StrHexize$(ad$)
			if respType == 2 then
				//Get local name
				tag = 0x09
				rc=BtcGetEIRbyTag(dta$, tag, name$)
				if rc == 0x5703 then
					tag = 0x08
					rc=BtcGetEIRbyTag(dta$, tag, name$)
				endif

				if rc == 0 then
					print "  ";name$
				endif		

			else
				print "  n/a"
			endif
			// Found the device so cancel inquiry
			rc = BtcInquiryCancel()
			AssertResCode(rc)
			print "\n";pr$

		endif
	endif

endfunc 1
//==============================================================================
// Called after an SPP connection attempt
//==============================================================================
function HandlerSppCon(hConn, res) as integer

	dim hz, conAddr$
    //if connected successfully
	if res == 0 then
		hcSpp = hConn
		hz = AcqConnHandle(hConn)
		conns = conns + 1
		rc = BtcGetBDAddrFromHandle(hConn,conAddr$)
		AssertResCode(rc)
		print "\nConnected to ";strhexize$(conAddr$)
		print "\nType \22^^^\22 for hangup\n"
		rc=SendMsgApp(0,RFCOMM_MODE)
		AssertResCode(rc)
	else
		print "\nConnection failed: ";res;"\n";pr$
    endif        

endfunc 1
//==============================================================================
// Called when a connection attempt to an SPP device times out
//==============================================================================
function HandlerSppConnTimOut() as integer

    print "\nCould not create connection: Connection timed out\n";pr$

endfunc 1
//==============================================================================
// Called when an SPP disconnection occurs
//==============================================================================
function HandlerSppDiscon(hConn)

    dim hz
    hz = RelConnHandle(hConn)
    conns = conns - 1
    print "\nDisconnected\n";pr$ 
	rc=SendMsgApp(0,NORMAL_MODE)
	AssertResCode(rc)

endfunc 1
//==============================================================================
// This handler is called when there is an inquiry timeout
//==============================================================================
function HandlerBtcInqTimOut() as integer 

	rc = BtcInquiryCancel()
	AssertResCode(rc)
	print "\n";pr$

endfunc 1
//==============================================================================
// This handler is called when there is an inquiry timeout
//==============================================================================
function HandlerBtcDiscTimOut() as integer

	//Set device discoverability depending on latest configuration
	rc = BtcSetDiscoverable(nDiscv, 300)
	AssertResCode(rc)

endfunc 1
//==============================================================================
// Called when data is received via SPP
//==============================================================================
function HandlerSppData()

    dim hPort, data$, rLen
    '//read and print data while there is data available to read
	while BtcSppRead(hPort, data$, rLen) == 0    
        if rLen>0 then
			print data$
        endif
    endwhile

endfunc 1
//==============================================================================
// Called when there is a pairing request from another device
//==============================================================================
function HandlerPairReq()

	dim s$
    rc=BtcGetPAIRRequestBDAddr(s$)
    prAddr$ = s$
	rc = BtcSendPAIRResp(1)
	AssertResCode(rc)

endfunc 1
//==============================================================================
// Called on a pin request from another device
//==============================================================================
function HandlerPINReq() 

	print "\nPIN feature will be added in future versions\n";pr$

endfunc 1
//==============================================================================
// Called after a pairing attempt
//==============================================================================
function HandlerPairRes(res)

	if res == 0 then
		print "\nPaired\n";pr$
	else
		print "\nPairing attempt failed : ";res;"\n";pr$
	endif

endfunc 1
//==============================================================================
// This handler is called when there is an inquiry report waiting to be read 
// Algorithm will prevent display of data from the same peer consecutively 
//==============================================================================
function HandlerAdvRpt() as integer

	dim ad$,dta$,ndisc,rsi,tag, nm$
	rc = BleScanGetAdvReport(ad$,dta$,ndisc,rsi)
	while rc==0
		ad$ = right$(ad$,8)
		print "\n		";strhexize$(ad$)
		tag = 0x09
		rc = BLEGETADBYTAG(dta$, tag, nm$)
		if rc == 0x6060 then
			tag = 0x08
			rc = BLEGETADBYTAG(dta$, tag, nm$)
		endif

		if rc == 0 then
			print "  ";nm$
		endif
		rc = BleScanGetAdvReport(ad$,dta$,ndisc,rsi)
	endwhile

endfunc 1
//==============================================================================
// This handler is called when there is a Ble connection timeout
//==============================================================================
function HandlerBleConnTimOut() as integer

	print "\nCould not create connection: Connection timed out\n";pr$

endfunc 1
//==============================================================================
// This handler is called when there is a Ble scan timeout
//==============================================================================
function HandlerBlrScanTimOut() as integer 

	rc = BleScanStop()
	AssertResCode(rc)
	print "\n";pr$

endfunc 1
//==============================================================================
// This handler is called when there is a BLE message
//==============================================================================
function HandlerBleMsg(BYVAL nMsgId AS INTEGER, BYVAL nCtx AS INTEGER) as integer

	dim hz

	select nMsgId
	
	case BLE_EVBLEMSGID_CONNECT
		hz = nCtx
		rc = AcqConnHandle(hz)
		conns = conns + 1
		print "\nConnection handle ";hz;"\n";pr$

	case BLE_EVBLEMSGID_DISCONNECT
		hz = RelConnHandle(nCtx)
		conns = conns - 1
		print "\nDisconnected\n";pr$

	case else
		//Unknown Ble Msg

  endselect

endfunc 1
//==============================================================================
// This handler is called when a BLE primary service is discovered
//==============================================================================
function HandlerPrimSvc(hConn,hUuid,hStart,hEnd) as integer

	if hUuid != 0 then
		if command == SMARTZ_COMMAND_GATTTOOL_PRIMARY then
			print "\n" 
			print "attr handle = 0x";integer.h' hStart
			print ", end grp handle = 0x";integer.h' hEnd
			print ", uuid = ";integer.h' hUuid
			rc = BleDiscServiceNext(hConn)

		elseif command == SMARTZ_COMMAND_GATTTOOL_CHARACTERISTICS then
			rc = BleDiscCharFirst(hConn,0,hStart,hEnd)

		endif

	else
		BleGattcClose()
		print "\n";pr$
		exitfunc 1

	endif
	
	
endfunc 1
//==============================================================================
// This handler is called when a BLE characteristic is discovered
//==============================================================================
function HandlerCharDisc(hConn,hUuid,cProp,hVal,hiUuid) as integer

	if hUuid != 0 then
		print "\n"
		print "handle = 0x";integer.h' hVal-1
		print ", char properties = 0x";integer.h' cProp
		print ", char value handle = 0x";integer.h' hVal
		print ", uuid = ";integer.h' hUuid
	endif

	rc = BleDiscCharNext(hConn)
	if rc != 0 then
		rc = BleDiscServiceNext(hConn)
		if rc !=0 then
			print "\n";pr$
			BleGattcClose()
		endif
	endif

endfunc 1
//==============================================================================
// This handler is called when a BLE descriptor is discovered
//==============================================================================
function HandlerDescDisc(hChar, hUuid, hDisc) as integer

	if hUuid !=0 then
		print "\n"
		print "handle : 0x";integer.h' hDisc;" uuid : ";integer.h' hUuid
	endif

	rc = BleDiscDescNext(hChar)
	if rc !=0 then
		print "\n";pr$
		BleGattcClose()
	endif

endfunc 1
//==============================================================================
// This handler is called when a BLE characteristic attribute has been read
//==============================================================================
function HandlerAttrRead(hConn,hAttr,nSts) as integer

	dim a$,ofst  
	if nSts == 0 then
		rc = BleGattcReadData(hConn,valHdl,ofst,a$)
		if rc==0 then
			print "\nCharacteristic value/descriptor: "
			print "";StrHexize$(a$)
			print " (";StrEscape$(a$);") \n";pr$
		else	
			AssertResCode(rc)
		endif
 
	else 
		_gattStatus(nSts)

	endif

	BleGattcClose()

endfunc 1
//==============================================================================
// This handler is called when a BLE characteristic attribute has been written to 
//==============================================================================
function HandlerAttrWrite(hConn,aHndl,nSts) as integer

	if nSts == 0 then
		print "\nCharacteristic value was written successfully\n";pr$
	else 
		_gattStatus(nSts)
	endif

endfunc 1
//==============================================================================
// This handler is called when there is data notified or indicated
//==============================================================================
function HandlerAttrNtfyCmd() as integer
  
	dim hConn,hAttr,att$,dscd

	if gattLsn == 1 then
		do
			rc=BleGattcNotifyRead(hConn,hAttr,att$,dscd)
			if rc==0 then
				print "\nNotification/Indication handle = 0x";integer.h' hAttr;" value: ";StrHexize$(att$)
			endif
		dowhile rc==0
	endif

endfunc 1
//==============================================================================
// Called when data is received via UART when bridged to SPP
//==============================================================================
function HandlerUartRxSpp()

	dim uLen, u$, nLen, nLen2 : uLen = 1
    while uLen != 0
        //read data that has arrived through via the UART
        uLen = UartRead(u$)
        if uLen > 0 then
			if uLen == 4 then
				// Check if received ^^^ in Line mode
				dim i$, j$
				i$ = u$
				rc = ExtractStrToken(i$,j$)
				if strcmp(j$,"^^^")==0 then 
					rc = BtcSppDisconnect(hcSpp)
					AssertResCode(rc)
				endif 
				STRSHIFTLEFT(u$, nLen)

            elseif StrCmp(u$,"^")==0 then
				carCnt = carCnt + 1
				if carCnt<3 then
					exitfunc 1
				else
					carCnt = 0
					rc = BtcSppDisconnect(hcSpp)
					AssertResCode(rc)
				endif

			else
				carCnt = 0
                //write data to most recent spp connection
                nLen2 = 0
                while nLen2 != uLen
                    rc = BtcSPPWrite(hcSpp, u$, nLen)
                    if rc != 0 then
                        //Assume problem with the SPP connection
                        exitfunc rc
                    endif
                    STRSHIFTLEFT(u$, nLen)
                    nLen2 = nLen2 + nLen
                endwhile
            endif
        endif

    endwhile

endfunc 1
//==============================================================================
// This handler is called when data has arrived at the serial port
//==============================================================================
function HandlerUartRxLsn() as integer

	dim nMatch

	nMatch=UartReadMatch(stRsp$,13)
	if nMatch!=0 then
		//CR exists in the input buffer
		urtcmd$ = strsplitleft$(stRsp$, nMatch)
		tlen = ExtractStrToken(urtcmd$,tkn$)
		if strcmp(tkn$,"stop")==0 then 
			gattLsn = 0
			print pr$
			rc = SendMsgApp(0, NORMAL_MODE)
			AssertResCode(rc)
		endif
	endif

endfunc 1
//==============================================================================
// This handler is called when data has arrived at the serial port
//==============================================================================
function HandlerUartRxCmd() as integer

	dim nMatch

	nMatch=UartReadMatch(stRsp$,13)
	if nMatch!=0 then
		//CR exists in the input buffer
		urtcmd$ = strsplitleft$(stRsp$, nMatch)
		exitfunc OnUartCmd()
	endif

endfunc 1
'//==============================================================================
'// Called after SendMsgApp is called. Used to switch between command and bridge mode
'//==============================================================================
function SetMode(msgID, cmd) as integer

	if cmd == NORMAL_MODE then
		OnEvent	 EVUARTRX					call HandlerUartRxCmd
		carCnt=0

	elseif cmd == RFCOMM_MODE then
		OnEvent	EVUARTRX					call HandlerUartRxSpp

	elseif cmd == GATTTOOL_LISTEN then	
		print "\nListening for notifications/indications. For hangup, type \22stop\22\n"
		OnEvent	EVUARTRX					call HandlerUartRxLsn

	endif

endfunc 1
//******************************************************************************

//******************************************************************************
// Equivalent to main() in C
//******************************************************************************

//------------------------------------------------------------------------------
// Enable synchronous event handlers
//------------------------------------------------------------------------------
// uart related events
OnEvent  EVUARTRX					call HandlerUartRxCmd

// hcitool related events (BTC)
OnEvent EVINQRESP					call HandlerInqResp
OnEvent	EVBTC_INQUIRY_TIMEOUT		call HandlerBtcInqTimOut	
OnEvent EVBTC_DISCOV_TIMEOUT		call HandlerBtcDiscTimOut

// rfcomm related events
OnEvent  EVSPPCONN                	call HandlerSppCon
OnEvent  EVBTC_SPP_CONN_TIMEOUT   	call HandlerSppConnTimOut
OnEvent  EVSPPDISCON              	call HandlerSppDiscon
OnEvent  EVBTC_SPP_DATA_RECEIVED  	call HandlerSppData

// hcitool related events (BTC)
OnEvent  EVBTC_PAIR_REQUEST       	call HandlerPairReq
OnEvent  EVBTC_PIN_REQUEST        	call HandlerPinReq
OnEvent  EVBTC_PAIR_RESULT        	call HandlerPairRes

// hcitool related events (BLE)
OnEvent EVBLE_ADV_REPORT			call HandlerAdvRpt
OnEvent  EVBLE_SCAN_TIMEOUT       	call HandlerBlrScanTimOut
OnEvent	EVBLE_CONN_TIMEOUT			call HandlerBleConnTimOut
OnEvent  EVBLEMSG                 	call HandlerBleMsg

// gatttool related events
OnEvent  EVDISCPRIMSVC            	call HandlerPrimSvc
OnEvent  EVDISCCHAR               	call HandlerCharDisc
OnEvent  EVDISCDESC               	call HandlerDescDisc
OnEvent  EVATTRREAD 				call HandlerAttrRead
OnEvent  EVATTRWRITE              	call HandlerAttrWrite


// Called for rfcomm connect and hangup
OnEvent  EVMSGAPP                 call SetMode
OnEvent	EVATTRNOTIFY             	call HandlerAttrNtfyCmd


//==============================================================================
//==============================================================================
sub Initialise()
	InitBtDevice()
	InitConnHandles()
	
	print "\n-----------------------\n"
	print " smartZ v";mjVersion;".";mnVersion;"\n"
	print "-----------------------\n"
	print "\nType \22help\22 or \22<command> help\22\n"
	print pr$
	
endsub
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
Initialise()

//------------------------------------------------------------------------------
// Wait for a synchronous event.
// An application can have multiple <WaitEvent> statements
//------------------------------------------------------------------------------
WaitEvent