//******************************************************************************
// Laird Technologies (c) 2014
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++                                                                      ++
// +++++  When UwTerminal downloads the app it will store it as a filenname   ++
// +++++  which consists of all characters up to the first . and excluding it ++
// +++++                                                                      ++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// This library file provides commands to control BT Classic operation and should be
// #included into the file 'cmd.ble.manager.sb' if running on a dual mode module
// e.g. BT900.
//
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Convention : (1) Case sensitive, and commands are presented in alphabetic order
//              (2) If line ends with \ then it continues on next line. That does
//                  not mean that it should be sent as multiple lines
//              (3) Replace anything between ## 
//              (4) #INTaaaa# means a number in decimal, hex, octal or binary
//                      format -> 23 == 0x17 == h'17 == o'23 == b'10111
//                      aaaa is just a description
//              (5) #HEXaaaa# means a string without delimitors consisting of hex 
//                      characters only aaaa is just a description
//              (6) #STRaaaa# means a string without delimitors
//                      aaaa is just a description
//              (7) "STRaaaa" means a string which must have the " delimitor
//                      aaaa is just a description
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// -----------------------------------------------------------------------------
// bridge spp
//   - Bridge to the most recent SPP connection. All data arriving via UART will
//     be sent over this connection.
//        
// -----------------------------------------------------------------------------
// inquiry config #INTcfgID# #INTvalue#
//    --- bluetooth classic functionality ---
//   - set scanning configuration parameters
//     #INTcfgID# 
//       0    Inquiry Type (0 for General Inquiry, 1 for Limited Inquiry)
//       1    Inquiry Mode (0 for Standard, 1 for with RSSI, 2 for Extended)
//       2    Max number of devices to receive inquiry responses from (0-255)
//       3    Inquiry Tx Power (Range is from -70 to 20 dBm)
//
// -----------------------------------------------------------------------------
// inquiry start #INTinqTimeoutS#
//    --- bluetooth classic functionality ---
//   - Start an inquiry using the timeout #INTinqTimeoutS#
//
// -----------------------------------------------------------------------------
// inquiry cancel
//    --- bluetooth classic functionality ---
//   - Cancel an ongoing inquiry
//
// -----------------------------------------------------------------------------
// spp open 
//    --- bluetooth classic functionality ---
//   - Open the serial port service and listen for SPP connections. Service handle is returned
//
// -----------------------------------------------------------------------------
// spp param #INTframesize# #INTincomingcredits#
//    --- bluetooth classic functionality ---
//   - Sets parameters for SPP connections (must be used before connections/servers are established)
//
// -----------------------------------------------------------------------------
// spp connect #HEXaddr6Bytes#
//    --- bluetooth classic functionality ---
//   - Connect to an SPP device defined by mac address #HEXaddr6Bytes#. Handle is returned
//
// -----------------------------------------------------------------------------
// spp disconnect #INThConnSpp#
//    --- bluetooth classic functionality ---
//   - Disconnect from an SPP device on the other end of connection with handle #INThConnSpp#
//
// -----------------------------------------------------------------------------
// spp close #INThSpp# 
//    --- bluetooth classic functionality ---
//   - Close the Serial Port with handle #INThSpp# being expedited by SPP Service.
//
// -----------------------------------------------------------------------------
// spp write #INThConnSpp# #STRdata#
//    --- bluetooth classic functionality ---
//   - Transmit data #STRdata# via the SPP connection identified by #INThConnSpp#
//
// -----------------------------------------------------------------------------
// btc getfriendlyname
//    --- bluetooth classic functionality ---
//    - calls BtcGetFriendlyName$() and prints the returned name
//
// -----------------------------------------------------------------------------
// btc setfriendlyname #STRname#
//    --- bluetooth classic functionality ---
//    - calls BtcSetFriendlyName$() with the name #STRname#
//
// -----------------------------------------------------------------------------
// btc getclassofdevice
//    --- bluetooth classic functionality ---
//    - calls BtcGetClassOfDevice() and prints the returned class
//
// -----------------------------------------------------------------------------
// btc setclassofdevice #INTCoD#
//    --- bluetooth classic functionality ---
//    - calls BtcSetClassOfDevice() with the value #INTCoD#
//
// -----------------------------------------------------------------------------
// btc discoveryconfig #INTcfgID# #INTval# 
//    --- bluetooth classic functionality ---
//    - configre discoverability parameters 
//
//     #INTcfgID# 
//       0    Discoverability Type (0 for General, 1 for Limited)
//       1    Inquiry Scan Interval 
//              Units: baseband slots (0.625 msec)
//              Range: 11.25 msec (0x0012) to 2560 msec (0x1000)
//              Default: 640ms (0x0400)
//       2    Inquiry Scan Window 
//              Units: baseband slots (0.625 msec)
//              Range: 11.25 msec (0x0012) to 2560 msec (0x1000)
//              Default: 320ms (0x0200)
//
// -----------------------------------------------------------------------------
// btc setdiscoverable #INTenable# #INTtimeout#
//    --- bluetooth classic functionality ---
//    - Set the module discoverable for time #INTtimeout# in seconds or not discoverable
//
//    #INTenable# 
//      0 = Not Discoverable
//      1 = Discoverable
//
// -----------------------------------------------------------------------------
// btc setconnectable #INTenable#
//    --- bluetooth classic functionality ---
//    - Enable or disable connectivity
//
//    #INTenable# 
//      0 = Not Connectable
//      1 = Connectable
//
// -----------------------------------------------------------------------------
// btc setpairable #INTenable#
//    --- bluetooth classic functionality ---
//    - Enable or disable pairability
//
//    #INTenable# 
//      0 = Not Pairable
//      1 = Pairable
//
// -----------------------------------------------------------------------------
// btc bond stats
//    --- bluetooth classic functionality ---
//    - Get the classic BT bonding manager database statistics.
//
// -----------------------------------------------------------------------------
// btc bond addkey #HEXaddr6Bytes# #HEXkey32Bytes# #INTkeyType#
//    --- bluetooth classic functionality ---
//    - Add a link key to the rolling database
//
// -----------------------------------------------------------------------------
// btc bond getkey #HEXaddr6Bytes#
//    --- bluetooth classic functionality ---
//    - Get a link key from the database for the BT address specified
//
// -----------------------------------------------------------------------------
// btc bond delkey #HEXaddr6Bytes#
//    --- bluetooth classic functionality ---
//    - Erase a link key from the database for the BT address specified.
//
// -----------------------------------------------------------------------------
// btc bond delall
//    --- bluetooth classic functionality ---
//    - Erase all link keys in the database (rolling and persistent)
//
// -----------------------------------------------------------------------------
// btc bond persistkey #HEXaddr6Bytes#
//    --- bluetooth classic functionality ---
//    - Make a link key persistent by transferring it from the rolling database 
//      to the persistent database
//
// -----------------------------------------------------------------------------
// btc bond getfirst
//    --- bluetooth classic functionality ---
//    - Get the first link key in the database
//
// -----------------------------------------------------------------------------
// btc bond getnext
//    --- bluetooth classic functionality ---
//    - Get the next link key in the database
//
// -----------------------------------------------------------------------------
// btc savepairings #INTflag#
//    --- bluetooth classic functionality ---
//    - Set whether to save pairing information (Bond) for subsequent incoming
//      pair requests
//
//    - #INTflag# - 0 : Do not store pairing information (Don’t bond)
//                  1 : Store pairing information (Bond)
//
// -----------------------------------------------------------------------------
// btc pair #HEXaddr6Bytes# #INTflag#
//    --- bluetooth classic functionality ---
//    - Pair with device with address #HEXaddr6Bytes# and specify whether to bond
//      with #INTflag# - 0 : Do not store pairing information (Don’t bond)
//                       1 : Store pairing information (Bond)
//                       2 : Use default as specified by 'btc savepairings'
//
// -----------------------------------------------------------------------------
// btc pairresp #INTpairResp#
//    --- bluetooth classic functionality ---
//    - Answer the pairing request
//      with #INTpairResp# - 0 : Decline pair request
//                           1 : Accept pair request
//
// -----------------------------------------------------------------------------
// btc passkey #INTpasskey#
//    --- bluetooth classic functionality ---
//    - Respond to a passkey request
//      with #INTpasskey# - As the passkey
//
// -----------------------------------------------------------------------------
// btc setoob #STRhash# #STRrand#
//    --- bluetooth classic functionality ---
//    - Respond to a OOB data request
//      with #STRhash# - As the OOB hash (16byte string)
//      with #STRrand# - As the OOB randomiser (16byte string)
//
// -----------------------------------------------------------------------------
// btc retrieveoob
//    --- bluetooth classic functionality ---
//    - Get the OOB data from baseband
//
// -----------------------------------------------------------------------------
// btc iocap #INTiocap#
//    --- bluetooth classic functionality ---
//    - Set the local IO capabilities
//      with #INTiocap# - 0 : NONE
//                        1 : DISPLAY_YESNO
//						  2 : KEYBOARD_ONLY
//						  3 : DISPLAY_ONLY
//
// -----------------------------------------------------------------------------
// btc oobpref #INToobpref#
//    --- bluetooth classic functionality ---
//    - Set the local IO capabilities to prefer OOB if available
//      with #INTiocap# - 0: FALSE
//						  1: TRUE
//						  2: ASK ME
//
// -----------------------------------------------------------------------------
// btc oobavailable #INToobavail#
//    --- bluetooth classic functionality ---
//    - Respond with OOB data availability
//      with #INToobavail# - 0: FALSE
//						  	 1: TRUE
//
// -----------------------------------------------------------------------------
// btc justworks #INTJWConf#
//    - Security Manager related
//    - This will result in BtcSecMngrJustWorksConf() being called
//    - valid values for #INTJWConf# are
//         0     Pairings works as-is without confirmation
//         1     Pairings requires confirmation
//
// -----------------------------------------------------------------------------
// btc setinformation #INTvidsrc# #INTvid# #INTpid# #INTversion# #STRdesc#
//    - Device Information service related
//    - This will result in BtcSetPNPInformation() being called
//    - valid values for #INTvidsrc# are
//         0x0001     Bluetooth VID base
//         0x0002     USB VID base
//
// -----------------------------------------------------------------------------
// btc sendpin #INTpin# 
//    --- bluetooth classic functionality ---
//    - Respond to a PIN request with #INTpin# during a pairing procedure
//
// -----------------------------------------------------------------------------
// misc i  clearall
//    - make all elements of the entire i[] array equal to 0
//
// -----------------------------------------------------------------------------
// misc i  set #INTidx# #INTval#
//    - i[#INTidx#] = #INTval#
//    - #INTidx# will be checked for valid index 
//
// -----------------------------------------------------------------------------
// misc s$ clearall
//    - make all elements of the entire s$[] array empty
//
// -----------------------------------------------------------------------------
// misc s$ set #INTidx# #STRescapedvalue#
//    - s$[#INTidx#] = #STRescapedvalue#
//    - #INTidx# will be checked for valid index 
//
// -----------------------------------------------------------------------------
//******************************************************************************

//******************************************************************************
// Definitions
//******************************************************************************
        // Number of spp ports
#define NUM_OF_SPP_PORTS                     8
#define EBTCAUTHKEYTYPE_NONE                 0
#define EBTCAUTHKEYTYPE_PASSKEY				 1
#define EBTCAUTHKEYTYPE_OOB					 2
#define EBTCAUTHKEYTYPE_PIN  				 3

#define EBTCIOCAPABILITY_NONE                   0
#define EBTCIOCAPABILITY_DISPLAY_YESNO          1
#define EBTCIOCAPABILITY_KEYBOARD_ONLY          2
#define EBTCIOCAPABILITY_DISPLAY_ONLY           3


//******************************************************************************
// Definitions
//******************************************************************************
'//Temporary workaround until BlePair is implemented for BL620
#define BLE_PAIR    BlePair(hc[i[1]], i[2])



//******************************************************************************
// Global Variable Declarations
//******************************************************************************
dim hcSpp                   //handle of connection to use for SPP service
dim hP[NUM_OF_SPP_PORTS+1]  //contains spp port handles
dim prAddr$              //BT address of last device pairing requested from or initiated with



//******************************************************************************
// Function and Subroutine definitions
//******************************************************************************

function ZeroPadInt$(nLength, nInt)
	dim PadString$, nExtend

	sprint #PadString$, nInt
	nExtend = nLength-strlen(PadString$)

	while (nExtend > 0)
		PadString$ = "0" + PadString$
		nExtend = nExtend - 1
	endwhile

endfunc PadString$

//==============================================================================
//==============================================================================
function AcqPortHandle()
  dim z
  for z=1 to (NUM_OF_SPP_PORTS)
    if hP[z] == -1 then
      exitfunc z
    endif
  next
endfunc 0

//==============================================================================
//==============================================================================
sub RelPortHandle(hPort)
  dim z
  for z=1 to (NUM_OF_SPP_PORTS)
    if hP[z] == hPort then 
      hP[z]=-1
      exitsub
    endif
  next
endsub

//-------------------------------------------------------------------------
//print the link data data
//-------------------------------------------------------------------------
sub PrintLinkKey()     
  print "\n Addr=";StrHexize$(s$[1]);" key=";StrHexize$(s$[2]);" keytype=";i[1]
  if i[2]==0 then
    print " PERSIST"
  else
    print " ROLLING"
  endif
endsub



//-------------------------------------------------------------------------
//#CMD#//  inquiry config #INTcfgID# #INTvalue#
//#CMD#//  inquiry start #INTinqTimeoutS#
//#CMD#//  inquiry cancel
//-------------------------------------------------------------------------
function _inquiry()  
    tlen = ExtractStrToken(urtcmd$,tkn$)
    if tlen == 0 then
        exitfunc 5
    endif
    
    if strcmp(tkn$,"cancel")==0 then
        //cancel the inquiry
        exitfunc BtcInquiryCancel()
    endif
    
    if strcmp(tkn$,"config")==0 then
        //extract 2 : (cfgID value) and store starting at i[1]
        rc = ExtractIntTokens(urtcmd$,1,2)
        if rc != 0 then
            exitfunc rc
        endif
        exitfunc BtcInquiryConfig(i[1],i[2])  
    endif
    if strcmp(tkn$,"start")==0 then
        //extract 1 : (inqTimeoutS) and store starting at i[1]
        rc = ExtractIntTokens(urtcmd$,1,1)
        if rc != 0 then
            exitfunc rc
        endif
        exitfunc BtcInquiryStart(i[1])
    endif
endfunc 5


//-------------------------------------------------------------------------
//#CMD#//  spp open
//#CMD#//  spp param #INTframesize# #INTincomingcredits#
//#CMD#//  spp connect #HEXaddr6Bytes#
//#CMD#//  spp disconnect #INThConnSpp#
//#CMD#//  spp close #INThSpp# 
//#CMD#//  spp write #INThConnSpp# #STRdata#
//-------------------------------------------------------------------------
function _spp()  
    tlen = ExtractStrToken(urtcmd$,tkn$)
    if tlen == 0 then
        exitfunc 5
    endif
    
    if strcmp(tkn$,"open")==0 then       
        dim ind : ind = AcqPortHandle()     //Get the next free index in the array of SPP port handles
        rc=BtcSppOpen(hP(ind))              //open the spp port. Store handle in the array at acquired index
        if rc==0 then
            print "\nSPP Port open. Handle = "; hP(ind)
            exitfunc 0
        else
            exitfunc rc
        endif
    
    elseif strcmp(tkn$,"param")==0 then
        //extract 2 : (framesize), (incomingcredits) and store starting at i[1]
        rc = ExtractIntTokens(urtcmd$,1,2)
        if rc != 0 then
            exitfunc rc
        endif
        exitfunc BtcSppSetParams(i[0], i[1])

    elseif strcmp(tkn$,"connect")==0 then
        //extract 1 : (addr6Bytes) and store starting at s$[1]
        rc = ExtractStrTokens(urtcmd$,1,1)
        if rc != 0 then
            exitfunc rc
        endif
        s$[1] = StrDeHexize$(s$[1])
        exitfunc BtcSppConnect(s$[1])  
   
    elseif strcmp(tkn$,"disconnect")==0 then
        //extract 1 : (hConnSpp) and store starting at i[1]
        rc = ExtractIntTokens(urtcmd$,1,1)
        if rc != 0 then
            exitfunc rc
        endif
        exitfunc BtcSppDisconnect(hc[i[1]])
    
    elseif strcmp(tkn$,"close")==0 then       
        rc = ExtractIntTokens(urtcmd$,1,1)
        if rc != 0 then
            exitfunc rc
        endif
        
        rc=BtcSppClose(i[1])              //close the spp port. Remove handle from the array

        if rc==0 then
            print "\nSPP Port closed. Handle = "; i[1]
            RelPortHandle(i[1])           //release the port with the given handle
            exitfunc 0
        else
            exitfunc rc
        endif
        
    elseif strcmp(tkn$,"write")==0 then
        dim wLen
        rc = ExtractIntTokens(urtcmd$,1,1)
        if rc != 0 then
            exitfunc rc
        endif
        
        StrShiftLeft(urtcmd$,1)
        
        // rc = ExtractStrTokens(urtcmd$,1,1)
        // if rc != 0 then
            // exitfunc rc
        // endif        
        exitfunc BtcSppWrite(hc[i[1]], urtcmd$, wLen)

    endif
endfunc 5


//-------------------------------------------------------------------------
//#CMD#//  btc bond stats
//#CMD#//  btc bond addkey #HEXaddr6Bytes# #HEXkey32Bytes# #INTkeyType#
//#CMD#//  btc bond getkey #HEXaddr6Bytes#
//#CMD#//  btc bond delkey #HEXaddr6Bytes#
//#CMD#//  btc bond delall
//#CMD#//  btc bond getfirst
//#CMD#//  btc bond getnext
//#CMD#//  btc bond persistkey #HEXaddr6Bytes#
//-------------------------------------------------------------------------
function _btcbond()  
  tlen = ExtractStrToken(urtcmd$,tkn$)
  if tlen > 0 then
    //=================================================
    if strcmp(tkn$,"stats")==0 then
      i[0]=BtcBondingStats(i[1],i[2])
      print "\n Capacity=";i[0];" Rolling=";i[1];" Persistent=";i[2];"\r"
      exitfunc 0
    endif
    //=================================================
    if strcmp(tkn$,"addkey")==0 then
      //#HEXaddr6Bytes#
      tlen = ExtractStrToken(urtcmd$,tkn$)
      if tlen > 0 then
        s$[1]=StrDehexize$(tkn$)
        if strlen(s$[1]) != 6 then
          exitfunc 5
        endif
      endif
      //#HEXkey32Bytes#
      tlen = ExtractStrToken(urtcmd$,tkn$)
      if tlen > 0 then
        s$[2]=StrDehexize$(tkn$)
        if strlen(s$[2]) != 16 then
          exitfunc 5
        endif
      endif
      //extract 1 : (#INTkeyType#) and store starting at i[1]
      rc = ExtractIntTokens(urtcmd$,1,1)
      if rc != 0 then
        exitfunc rc
      endif        
      exitfunc BtcBondingAddKey(s$[1],s$[2],i[1])
    endif
    //=================================================
    if strcmp(tkn$,"getkey")==0 then
      //#HEXaddr6Bytes#
      tlen = ExtractStrToken(urtcmd$,tkn$)
      if tlen > 0 then
        s$[1]=StrDehexize$(tkn$)
        if strlen(s$[1]) != 6 then
          exitfunc 5
        endif
      endif
      rc = BtcBondingGetKey(s$[1],s$[2],i[1],i[2])
      if rc!=0 then
        exitfunc rc
      endif
      //print the link data data
      PrintLinkKey()
      exitfunc 0
    endif
    //=================================================
    if strcmp(tkn$,"delkey")==0 then
      //#HEXaddr6Bytes#
      tlen = ExtractStrToken(urtcmd$,tkn$)
      if tlen > 0 then
        s$[1]=StrDehexize$(tkn$)
        if strlen(s$[1]) != 6 then
          exitfunc 5
        endif
      endif
      exitfunc BtcBondingEraseKey(s$[1])
    endif
    //=================================================
    if strcmp(tkn$,"delall")==0 then
      exitfunc BtcBondingEraseAll()
    endif
    //=================================================
    if strcmp(tkn$,"getfirst")==0 then
      rc = BtcBondingGetFirst(s$[1],s$[2],i[1],i[2])
      if rc!=0 then
        exitfunc rc
      endif
      //print the data
      PrintLinkKey()
      exitfunc 0
    endif
    //=================================================
    if strcmp(tkn$,"getnext")==0 then
      rc = BtcBondingGetNext(s$[1],s$[2],i[1],i[2])
      if rc!=0 then
        exitfunc rc
      endif
      //print the data
      PrintLinkKey()
      exitfunc 0
    endif
    //=================================================
    if strcmp(tkn$,"persistkey")==0 then
      //#HEXaddr6Bytes#
      tlen = ExtractStrToken(urtcmd$,tkn$)
      if tlen > 0 then
        s$[1]=StrDehexize$(tkn$)
        if strlen(s$[1]) != 6 then
          exitfunc 5
        endif
      endif
      exitfunc BtcBondingPersistKey(s$[1])
    endif
  endif
endfunc 5

//-------------------------------------------------------------------------
//#CMD#//  hid device open #STRdescriptor# #INTFeatures# #INTSubclass# #STRname#
//#CMD#//  hid host open
//#CMD#//  hid close
//#CMD#//  hid connect #STRaddr#
//#CMD#//  hid disconnect #INTConHandle#
//#CMD#//  hid control #INTConHandle# #INTControl#
//-------------------------------------------------------------------------
function _hid()  
    tlen = ExtractStrToken(urtcmd$,tkn$)
    if tlen == 0 then
        exitfunc 5
    endif
    
	if strcmp(tkn$,"device")==0 then
		tlen = ExtractStrToken(urtcmd$,tkn$)
		if tlen == 0 then
		  exitfunc 5
		endif 
		
		if strcmp(tkn$,"open")==0 then       
			rc = ExtractStrTokens(urtcmd$,1,1)
			if rc != 0 then
				exitfunc rc
			endif
			
			rc = ExtractIntTokens(urtcmd$,1,3)
			if rc != 0 then
				exitfunc rc
			endif
			
			rc = ExtractStrTokens(urtcmd$,2,1)
			if rc != 0 then
				exitfunc rc
			endif
			
			rc = BtcHIDDeviceOpen(s$[1], i[1], i[2], i[3], s$[2])
			if rc==0 then
				print "\nHID Device opened."
				exitfunc 0
			else
				exitfunc rc
			endif
		endif
	endif
	if strcmp(tkn$,"host")==0 then
		tlen = ExtractStrToken(urtcmd$,tkn$)
		if tlen == 0 then
		  exitfunc 5
		endif 
		
		if strcmp(tkn$,"open")==0 then       		
			rc = BtcHIDHostOpen()
			if rc==0 then
				print "\nHID Host opened."
				exitfunc 0
			else
				exitfunc rc
			endif
		endif
	endif
	if strcmp(tkn$,"close")==0 then              
		rc=BtcHIDClose()
		if rc==0 then
			print "\nHID Closed."
			exitfunc 0
		else
			exitfunc rc
		endif
	endif
	if strcmp(tkn$,"connect")==0 then
		tlen = ExtractStrToken(urtcmd$,tkn$)
		if tlen == 0 then
			exitfunc 5
		endif
		//the current token has to be a mac address
		s$[1]=StrDehexize$(tkn$)
		if strlen(s$[1]) != 6 then
			exitfunc 5
		endif
		
		exitfunc BtcHIDConnect(s$[1])
	endif
	if strcmp(tkn$,"disconnect")==0 then
		//extract 1 : (hConnSpp) and store starting at i[1]
        rc = ExtractIntTokens(urtcmd$,1,1)
        if rc != 0 then
            exitfunc rc
        endif
        exitfunc BtcHIDDisconnect(hc[i[1]])
	endif
	if strcmp(tkn$,"control")==0 then
		//extract 1 : (hConnSpp) and store starting at i[1], get the control number too
        rc = ExtractIntTokens(urtcmd$,1,2)
        if rc != 0 then
            exitfunc rc
        endif
        exitfunc BtcHIDControl(hc[i[1]],i[2])
	endif
endfunc 5

//-------------------------------------------------------------------------
//#CMD#//  btc getfriendlyname
//#CMD#//  btc setfriendlyname #STRname#
//#CMD#//  btc getclassofdevice
//#CMD#//  btc setclassofdevice #INTCoD#
//#CMD#//  btc sendpin #INTpin#
//#CMD#//  btc savepairings #INTflag#
//#CMD#//  btc pair #HEXaddr6Bytes# #INTflag#
//#CMD#//  btc pairresp #INTpairResp#
//#CMD#//  btc discoveryconfig #INTcfgID# #INTval#
//#CMD#//  btc setdiscoverable #INTenable# #INTtimeout#
//#CMD#//  btc setpairable #INTenable#
//#CMD#//  btc setconnectable #INTenable#
//#CMD#//  btc passkey #INTval#
//#CMD#//  btc setoob #STRhash# #STRrand#
//#CMD#//  btc retrieveoob
//#CMD#//  btc iocap #INTval#
//#CMD#//  btc oobpref #INTval#
//#CMD#//  btc oobavailable #INTval#
//#CMD#//  btc justworks  #INTJWConf#
//#CMD#//  btc setinformation #INTvidsrc# #INTvid# #INTpid# #INTversion# #STRdesc#


//-------------------------------------------------------------------------
function _btc() 
    tlen = ExtractStrToken(urtcmd$,tkn$)
    if tlen == 0 then
        exitfunc 5
    endif
      
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  
    if strcmp(tkn$,"getfriendlyname")==0 then       
        dim nme$
        rc=BtcGetFriendlyName(nme$)
        if rc== 0 then
            print "\n";nme$
            exitfunc 0
        else
            exitfunc rc
        endif
    endif
    
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    
    if strcmp(tkn$,"setfriendlyname")==0 then       
        rc = ExtractStrTokens(urtcmd$,1,1)
        if rc != 0 then
            exitfunc rc
        endif
        
        exitfunc BtcSetFriendlyName(s$[1])
    endif
	
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  
    if strcmp(tkn$,"getclassofdevice")==0 then       
        dim nCoD
        rc=BtcGetClassOfDevice(nCoD)
        if rc== 0 then
            print "\n";integer.h'nCoD
            exitfunc 0
        else
            exitfunc rc
        endif
    endif
    
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    
    if strcmp(tkn$,"setclassofdevice")==0 then       
        rc = ExtractIntTokens(urtcmd$,1,1)
        if rc != 0 then
            exitfunc rc
        endif
        
        exitfunc BtcSetClassOfDevice(i[1])
    endif
    
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"sendpin")==0 then
        rc = ExtractStrTokens(urtcmd$,1,1)
        if rc != 0 then
            exitfunc rc
        endif
        
        exitfunc BtcSendPINResp(s$[1])
    endif
    
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"bond")==0 then
        exitfunc _btcbond()
    endif
    
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    
    if strcmp(tkn$,"savepairings")==0 then
        rc = ExtractIntTokens(urtcmd$,1,1)
        if rc != 0 then
            exitfunc rc
        endif
        
        exitfunc BtcSavePairings(i[1])
    endif
    
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"pair")==0 then
        rc = ExtractStrTokens(urtcmd$,1,2)
        if rc != 0 then
            exitfunc rc
        endif
        
        s$[1] = StrDehexize$(s$[1])
        exitfunc BtcPair(s$[1], StrValDec(s$[2]))
    endif
    
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"pairresp")==0 then
        rc = ExtractIntTokens(urtcmd$,1,1)
        if rc != 0 then
            exitfunc rc
        endif
        
        exitfunc BtcSendPAIRResp(i[1])
    endif

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"justworks")==0 then
        //extract 1 (#INTJWConf#) and store starting at i[1]
        rc = ExtractIntTokens(urtcmd$,1,1)
        if rc != 0 then
            exitfunc rc
        endif
        exitfunc BtcSecMngrJustWorksConf(i[1])
    endif
	
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"setinformation")==0 then
        //extract 1 (#INTJWConf#) and store starting at i[1]
        rc = ExtractIntTokens(urtcmd$,1,4)
        if rc != 0 then
            exitfunc rc
        endif
		rc = ExtractStrTokens(urtcmd$,1,1)
        if rc != 0 then
            exitfunc rc
        endif		
        exitfunc BtcSetPNPInformation(i[1], i[2], i[3], i[4], s$[1])
    endif
	
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"passkey")==0 then
        rc = ExtractIntTokens(urtcmd$,1,1)
        if rc != 0 then
            exitfunc rc
        endif
        
        exitfunc BtcSecMngrPassKey(i[1])
    endif
	
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"setoob")==0 then
        rc = ExtractStrTokens(urtcmd$,1,2)
        if rc != 0 then
            exitfunc rc
        endif
        s$[1] = StrDehexize$(s$[1])
		s$[2] = StrDehexize$(s$[2])
        exitfunc BtcSecMngrOobKey(s$[1], s$[2])
    endif
	
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"retrieveoob")==0 then
        rc = BtcSecMngrRetrieveLocalOobKey(s$[1], s$[2])
		if rc != 0 then
            exitfunc rc
        endif
		print "\nHash: "; StrHexize$(s$[1])
		print "\nRandomiser: "; StrHexize$(s$[2])	
		exitfunc rc
    endif
	
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"oobpref")==0 then
        rc = ExtractIntTokens(urtcmd$,1,1)
        if rc != 0 then
            exitfunc rc
        endif
        
        exitfunc BtcSecMngrOobPref(i[1])
    endif
	
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"oobavailable")==0 then
        rc = ExtractIntTokens(urtcmd$,1,1)
        if rc != 0 then
            exitfunc rc
        endif
        
        exitfunc BtcSecMngrOobAvailable(i[1])
    endif

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    
    if strcmp(tkn$,"iocap")==0 then
        rc = ExtractIntTokens(urtcmd$,1,1)
        if rc != 0 then
            exitfunc rc
        endif
        
        exitfunc BtcSecMngrIoCap(i[1])
    endif
    
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"discoveryconfig")==0 then
        //extract 2 : (#INTcfgID# #INTval#) and store starting at i[1]
        rc = ExtractIntTokens(urtcmd$,1,2)
        if rc != 0 then
            exitfunc rc
        endif
        
        exitfunc BtcDiscoveryConfig(i[1], i[2])
    endif
        
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"setdiscoverable")==0 then
        //extract 2 : (#INTenable# #INTtimeout#) and store starting at i[1]
        rc = ExtractIntTokens(urtcmd$,1,2)
        if rc != 0 then
            exitfunc rc
        endif
        
        exitfunc BtcSetDiscoverable(i[1], i[2])
    endif
    
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"setpairable")==0 then
        //extract 1 : (#INTenable#) and store starting at i[1]
        rc = ExtractIntTokens(urtcmd$,1,1)
        if rc != 0 then
            exitfunc rc
        endif
        
        exitfunc BtcSetPairable(i[1])
    endif
    
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if strcmp(tkn$,"setconnectable")==0 then
        //extract 1 : (#INTenable#) and store starting at i[1]
        rc = ExtractIntTokens(urtcmd$,1,1)
        if rc != 0 then
            exitfunc rc
        endif
        
        exitfunc BtcSetConnectable(i[1])
    endif
    
endfunc 5






'//******************************************************************************
'// Handler definitions
'//******************************************************************************
//==============================================================================
// This handler is called when there is an inquiry report waiting to be read
//==============================================================================
function HandlerInqResp(respType) as integer
    dim ad$,dta$,ndx,rsi,tag
    rc = BtcInquiryGetReport(ad$,dta$,ndx,rsi)
        print "\nMAC: "; StrHexize$(ad$)
      
        if respType > 0 then
            print " ";rsi
            
            if respType == 2 then
                print "\n  EIR: "; StrHexize$(dta$)
                dim tg$
                while BtcGetEIRbyIndex(ndx,dta$,tag,ad$)==0
                    //write tag value as hex to string tg$
                    sprint #tg$,integer.h'tag
                    
                    //hexize eir tag data if not a shortened or complete local name
                    if tag < 0x08 || tag > 0x09 then
                        
                        ad$ = StrHexize$(ad$)
                    else
                        StrDeescape(ad$)
                    endif
                    
                    //print the last 2 hex digits of the tag, and the data
                    if strlen(ad$)!=0 then
                        print "\n  - Tag 0x" + RIGHT$(tg$,2) +": "; ad$
                    endif
                                           
                    ndx=ndx+1
                endwhile
                print "\n"
            endif
        endif
    // endif
endfunc 1


//==============================================================================
// This handler is called when there is an inquiry timeout
//==============================================================================
function HandlerBtcInqTimOut() as integer
    UartRsp(0)
endfunc 1


//==============================================================================
// This handler is called when there is an discoverability timeout
//==============================================================================
function HandlerBtcDiscTimOut() as integer
    print "\n --- No longer discoverable"
    UartRsp(0)
endfunc 1


//==============================================================================
// Called after an SPP connection attempt
//==============================================================================
function HandlerSppCon(hConn, res) as integer
    dim hz

    print "\n --- SPP Connect: (";integer.h' res;")"
    //if connected successfully
    if res == 0 then
        //try and acquire a connection handle
        hz = AcqConnHandle(hConn)
        
        //disconnect if failed
        if hz==0 then
            rc=BtcSppDisconnect(hConn)
            print " DROPPED"
        else
            hcSpp = hc[hz]     //always assume most recent connection for SPP
            conns = conns + 1
            print " handle = ";hz;pr$
        endif
    endif        
endfunc 1


//==============================================================================
// Called when a connection attempt to an SPP device times out
//==============================================================================
function HandlerSppConnTimOut() as integer
    DbgMsg( "\n --- SPP Conn Attempt Timeout" )
endfunc 1


//==============================================================================
// Called when an SPP disconnection occurs
//==============================================================================
function HandlerSppDiscon(hConn)
    dim hz
    
    hz = RelConnHandle(hConn)
    conns = conns - 1
    print "\n --- Spp Disconnect: handle=";hz
endfunc 1


//==============================================================================
// Called when data is received via UART when bridged to SPP
//==============================================================================
function HandlerUartRxSpp()
    dim uLen, u$, nLen, nLen2 : uLen = 1
    WHILE uLen != 0
        //read data that has arrived through via the UART
        uLen = UartRead(u$) 
    
        if uLen > 0 then
            if StrCmp(u$,"^")==0 then
                // print "\nBefore: ";carCnt                 
                if TimerRunning(0)==0 then
                    carCnt = carCnt + 1
                    if carCnt<3 then
                        TimerStart(0,CAR_PRESS_DELAY,0) 
                    else
                        rc=SendMsgApp(0,CMD_MODE)    //* Using this for switching between bridge and cmd mode
                    endif
                else    //invalid press                    
                    TimerCancel(0)
                    carCnt = 0
                endif
            else
                //write data to most recent spp connection
                nLen2 = 0
                WHILE nLen2 != uLen
                    rc = BtcSPPWrite(hcSpp, u$, nLen)
                    IF rc != 0 THEN
                        //Assume problem with the SPP connection
                        exitfunc rc
                    ENDIF
                    STRSHIFTLEFT(u$, nLen)
                    nLen2 = nLen2 + nLen
                ENDWHILE
            endif
        endif
    ENDWHILE
endfunc 1


//==============================================================================
// Called when data is received via SPP - CMD mode
//==============================================================================
function HandlerSppDataCmd()
    dim hPort, data$, rLen, hz

    '//read and print data while there is data available to read
	do
		rc = BtcSppRead(hPort, data$, rLen)
        if rLen>0 && rc ==0 then
            hz = GetConnHandle(hPort)
            print"\nPort Handle: ";hz; " Length: ";rLen;"\nData: ";data$;pr$
        endif
	dowhile rLen>0 && rc ==0
endfunc 1


//==============================================================================
// Called when data is received via SPP - BRIDGE mode
//==============================================================================
function HandlerSppData()
    dim hPort, data$, rLen
    
    '//read and print data while there is data available to read
	do
		rc = BtcSppRead(hPort, data$, rLen)
        if rLen>0 && rc ==0 then
            print data$
        endif
	dowhile rLen>0 && rc ==0
endfunc 1

//==============================================================================
// Called when there is a pairing request from another device
//==============================================================================
function HandlerAuthReq(reqType) 
	dim mac$
    rc=BtcGetPairRequestBDAddr(mac$)
	prAddr$ = mac$
	if rc==0 then
		if reqType == EBTCAUTHKEYTYPE_NONE then
			print "\nPair Req: "; StrHexize$(mac$);pr$
		elseif reqType == EBTCAUTHKEYTYPE_PASSKEY then
			print "\nPasskey Req: "; StrHexize$(mac$);pr$
		elseif reqType == EBTCAUTHKEYTYPE_OOB then
			print "\nOOB Req: "; StrHexize$(mac$);pr$
		elseif reqtype == EBTCAUTHKEYTYPE_PIN then
			print "\nPIN Req: "; StrHexize$(mac$);pr$
		endif	
	else
        AssertResCode(rc,2277)
    endif
	
endfunc 1

//==============================================================================
// Called when there is a OOB data availability request
//==============================================================================
function HandlerOOBAvail() 
	dim mac$
    rc=BtcGetPairRequestBDAddr(mac$)
	prAddr$ = mac$
	
	print "\nOOB data available for: "; StrHexize$(mac$);" ?";pr$
endfunc 1

//==============================================================================
// Called when there is a pairing request from another device
//==============================================================================
function HandlerPasskey(passkey) 
	print "\nPasskey: "; ZeroPadInt$(6, passkey); pr$	
endfunc 1

//==============================================================================
// Called after a pairing attempt
//==============================================================================
function HandlerPairRes(res)
    print "\nPair Result: ";res; " "; StrHexize$(prAddr$);pr$
endfunc 1


//==============================================================================
// Called after an SPP connection attempt
//==============================================================================
function HandlerHIDCon(hConn, res) as integer
    dim hz

    print "\n --- HID Connect: (";integer.h' res;")"
    //if connected successfully
    if res == 0 then
        //try and acquire a connection handle
        hz = AcqConnHandle(hConn)
        
        //disconnect if failed
        if hz==0 then
            rc=BtcHIDDisconnect(hConn)
            print " DROPPED"
        else
            hcSpp = hc[hz]     //always assume most recent connection for HID
            conns = conns + 1
            print " handle=";hz;pr$
        endif
    endif        
endfunc 1

//==============================================================================
// Called when an HID disconnection occurs
//==============================================================================
function HandlerHIDDiscon(hConn)
    dim hz
    
    hz = RelConnHandle(hConn)
    conns = conns - 1
    print "\n --- HID Disconnect: handle=";hz
endfunc 1

//==============================================================================
// Called after an HID control event
//==============================================================================
function HandlerHIDControl(hConn, nControl) as integer
    dim hz
	hz = GetConnHandle(hConn)
	
    print "\n --- HID Control: (";integer.h' nControl;") handle=";hz;pr$
         
endfunc 1

//==============================================================================
// Called when switching to command mode to register SPP event handler
//==============================================================================
sub OnSetModeCmd() 
    OnEvent  EVBTC_SPP_DATA_RECEIVED call HandlerSppDataCmd
endsub


//==============================================================================
// Called when switching to SPP mode to register SPP event handler
//==============================================================================
sub OnSetModeSpp() 
    OnEvent  EVBTC_SPP_DATA_RECEIVED call HandlerSppData
endsub

'//******************************************************************************
'// Equivalent to main() in C
'//******************************************************************************
OnEvent  EVINQRESP                call HandlerInqResp
OnEvent  EVBTC_INQUIRY_TIMEOUT    call HandlerBtcInqTimOut
OnEvent  EVBTC_DISCOV_TIMEOUT     call HandlerBtcDiscTimOut  

OnEvent  EVBTC_OOB_AVAILABLE_REQUEST call HandlerOOBAvail
OnEvent  EVBTC_AUTHREQ			  call HandlerAuthReq
OnEvent  EVBTC_PASSKEY			  call HandlerPasskey
OnEvent  EVBTC_PAIR_RESULT        call HandlerPairRes

OnEvent  EVHIDCONN				  call HandlerHIDCon
OnEvent  EVHIDDISCON		      call HandlerHIDDiscon
OnEvent  EVHIDCONTROL			  call HandlerHIDControl

OnEvent  EVSPPCONN                call HandlerSppCon
OnEvent  EVBTC_SPP_CONN_TIMEOUT   call HandlerSppConnTimOut
OnEvent  EVSPPDISCON              call HandlerSppDiscon
OnEvent  EVBTC_SPP_DATA_RECEIVED  call HandlerSppDataCmd