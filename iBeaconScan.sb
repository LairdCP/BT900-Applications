//******************************************************************************
// Laird Technologies (c) 2014
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++                                                                      ++
// +++++  When UwTerminal downloads the app it will store it as a filenname   ++
// +++++  which consists of all characters up to the first . and excluding it ++
// +++++                                                                      ++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Version 0.8, 10/09/2014
// This app provides iBeacon scanning and listing for use with the BT900 module
// as follows:-
//
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Convention : (1) Case sensitive, and commands are presented in alphabetic order
//              (2) If line ends with \ then it continues on next line. That does
//                  not mean that it should be sent as multiple lines
//              (3) Replace anything between ## 
//              (4) #INTaaaa# means a number in decimal, hex, octal or binary
//                      format -> 23 == 0x17 == h'17 == o'23 == b'10111
//                      aaaa is just a description
//              (5) #HEXaaaa# means a string without delimitors consisting of hex 
//                      characters only aaaa is just a description
//              (6) #STRaaaa# means a string without delimitors
//                      aaaa is just a description
//              (7) "STRaaaa" means a string which must have the " delimitor
//                      aaaa is just a description
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// -----------------------------------------------------------------------------
// scan
//   - Starts scanning for iBeacons using the setup configuration
//
// -----------------------------------------------------------------------------
// stop
//   - Stops any current iBeacon scans that are in progress
//
// -----------------------------------------------------------------------------
// quit
//   - Exits the application and returns to command mode
//
// -----------------------------------------------------------------------------
// exit
//   - Exits the application and returns to command mode
//
// -----------------------------------------------------------------------------
// config displaymode #INTmode#
//   - Changes how the output from each iBeacon advert is displayed:
//     0 : mac + name + rssi + uuid + version + power
//     1 : mac + name + rssi + version + power
//     2 : mac + rssi + version + power
//     3 : mac + rssi + power
//     4 : mac + rssi
//     5 : mac + name + rssi + power
//     6 : mac + name + rssi
//     7 : name + rssi + uuid + version + power
//     8 : name + rssi + version + power
//     9 : name + rssi + power
//     10: name + rssi
//
// -----------------------------------------------------------------------------
// config timeout #INTtimeoutsec#
//   - Sets the iBeacon scan timeout (in seconds). After scanning for this time
//     the scan will automatically stop. Set to 0 for infinite scanning
//
// -----------------------------------------------------------------------------
// config duplicates #INTshowduplicates#
//   - Shows or hides duplicate iBeacon packets. Will hide duplicates when set
//     to 0 and will show duplicates when set to 1.
//
// -----------------------------------------------------------------------------
// config devices #INTdevicestoshow#
//   - Sets the maximum number of devices to detect when scanning. If this limit
//     is reached then scanning with automatically stop. Set to 0 for infinite
//     scanning.
//
// -----------------------------------------------------------------------------
// config txpower #INTtxpower#
//   - Sets transmit Tx power of the module in dBm (valid values: 4, 0, -4, -8, 
//     -12, -16, -20, -30 and -55).
//
// -----------------------------------------------------------------------------

//******************************************************************************
// Definitions
//******************************************************************************

        //Set this to 0 to disable all debugging messages
#define ENABLE_DEBUG_PRINTS                  1
        // Number of connections
#define NUM_OF_CONNS                         8
        // size of i[]
#define NUM_OF_I_PARAMS                     (8)
        // size of s$[] and must be at least 8 elements for BleSvcRegDevInfo()     
#define NUM_OF_S_PARAMS                     (8)


//BLE EVENT MSG IDs
#define BLE_EVBLEMSGID_CONNECT                          0 // msgCtx = connection handle
#define BLE_EVBLEMSGID_DISCONNECT                       1 // msgCtx = connection handle
#define BLE_EVBLEMSGID_IMMEDIATE_ALERT_SERVICE_ALERT    2 // msgCtx = alert level
#define BLE_EVBLEMSGID_LINKLOSS_SERVICE_ALERT           3 // msgCtx = alert level
#define BLE_EVBLEMSGID_SERVICE_ERROR                    4 // msgCtx = resultcode
#define BLE_EVBLEMSGID_HTS_INDICATION_STATE             5 // msgCtx = new indication state 0=off, 1=on
#define BLE_EVBLEMSGID_HTS_INDICATION_CNF               6 // msgCtx = not used
#define BLE_EVBLEMSGID_BPS_INDICATION_STATE             7 // msgCtx = new indication state 0=off, 1=on
#define BLE_EVBLEMSGID_BPS_INDICATION_CNF               8 // msgCtx = not used
#define BLE_EVBLEMSGID_DISPLAY_PASSKEY                  9 // msgCtx = passcode to display
#define BLE_EVBLEMSGID_NEW_BOND                        10 // msgCtx = connection handle
#define BLE_EVBLEMSGID_AUTH_KEY_REQUEST                11 // msgCtx = 1 for passkey, 2 for 16 byte OOB data
#define BLE_EVBLEMSGID_HRS_NOTIFICATION_STATE          12 // msgCtx = new notification state 0=off, 1=on
//#define FUTURE_USE                                   13
#define BLE_EVBLEMSGID_CONN_PARMS_UPDATE               14 // msgCtx = connection handle
#define BLE_EVBLEMSGID_CONN_PARMS_UPDATE_FAIL          15 // msgCtx = connection handle
#define BLE_EVBLEMSGID_CONN_TO_BONDED_MASTER           16 // msgCtx = connection handle
#define BLE_EVBLEMSGID_UPDATED_BOND                    17 // msgCtx = connection handle
#define BLE_EVBLEMSGID_ENCRYPTED                       18 // msgCtx = connection handle
#define BLE_EVBLEMSGID_POWER_FAILURE_WARNING           19 // msgCtx = current supply voltage
#define BLE_EVBLEMSGID_UNENCRYPTED                     20 // msgCtx = connection handle
#define BLE_EVBLEMSGID_DEVICENAME_WRITE                21 // msgCtx = connection handle
//******************************************************************************
// Global Variable Declarations
//******************************************************************************

dim rc
dim stRsp$ as string        //Uart rx data is stored here

dim ok$,er$,pr$

dim i[NUM_OF_I_PARAMS]      //index 0 used for return values
dim s$[NUM_OF_S_PARAMS]     //must be at least 8 elements for BleSvcRegDevInfo()

dim urtcmd$                 //cmd line from uart
dim tkn$,tlen               //used by command parser
dim hc[NUM_OF_CONNS+1]      //contains connection handles
dim conns                   //number of connections
dim urts                    //will be <0 if uart parser suspended
dim carCnt                  //count variable for number of times '^' entered
dim DisplayMode             //What is displayed on the output
dim ScanTimeout             //When a scan will timeout (seconds)
dim ScanDuplicates          //Set to 1 to show duplicate devices
dim ScanDevices             //Maximum number of devices to discover
dim ScanTable$              //Table containing IDs of devices
dim ScanDeviceCount         //Number of devices found on this scan

//******************************************************************************
// Initialisse Global Variable
//******************************************************************************

ok$    = "\nOK"
er$    = "\nERROR "
pr$    = "\r\n>"

urts = 0            //not suspended
conns = 0           //number of connections
DisplayMode = 0     //Output display mode
ScanTimeout = 10    //Default scan time of 10 seconds
ScanDuplicates = 0  //Do not show duplicates
ScanDevices = 0     //Unlimited number of devices
ScanDeviceCount = 0 //No devices found yet

//******************************************************************************
// Register Error Handler as early as possible
//******************************************************************************
sub HandlerOnErr()
  if (ENABLE_DEBUG_PRINTS!=0) then
    print "\n OnErr - ";GetLastError();"\n"
  endif
endsub
onerror next HandlerOnErr

//******************************************************************************
// Debugging resource as early as possible
//******************************************************************************

//==============================================================================
//==============================================================================
sub AssertResCode(byval rc as integer,byval tag as integer)
  if (ENABLE_DEBUG_PRINTS!=0) && (rc!=0) then
    print "\nFailed with ";integer.h' rc;" at tag ";tag
  endif
endsub

//==============================================================================
//==============================================================================
sub DbgMsg(byval msg$ as string)
  if (ENABLE_DEBUG_PRINTS!=0) then
    print "\n";msg$
  endif
endsub

//==============================================================================
//==============================================================================
sub DbgMsgVal(byval msg$ as string, byval vl as integer)
  if (ENABLE_DEBUG_PRINTS!=0) then
    print "\n";msg$;" ";vl
  endif
endsub

//==============================================================================
//==============================================================================
sub UartRsp(rsp as integer)
    if rsp == 0 then
        print ok$;pr$
    elseif rsp == -2 then
        print pr$
    elseif rsp > 0 then 
        print er$;integer.h' rsp;pr$
    endif
endsub

//-------------------------------------------------------------------------
//-------------------------------------------------------------------------
function ExtractIntTokens(u$,stIdx,num)
  while num>0
    tlen = ExtractIntToken(u$,i[stIdx])
    if tlen == 0 then
      exitfunc 4
    endif
    num=num-1
    stIdx = stIdx+1
  endwhile
endfunc 0

//-------------------------------------------------------------------------
//-------------------------------------------------------------------------
function ExtractStrTokens(u$,stIdx,num)
  while num>0
    tlen = ExtractStrToken(u$,s$[stIdx])
    if tlen == 0 then
      exitfunc 3
    endif
    num=num-1
    stIdx = stIdx+1
  endwhile
endfunc 0

//==============================================================================
// This handler is called when there is an advert report waiting to be read
//==============================================================================
function HandlerAdvRpt() as integer
    dim ad$,dta$,ndisc,rsi
    dim ADval1$, ADval2$
    rc = BleScanGetAdvReport(ad$,dta$,ndisc,rsi)
    while rc==0
        //Get device name
        rc = BleGetADByTag(dta$, 0x09, ADval1$)
'        iBeacon tag:
'        0,1 = company id
'        2,3 = data type
'        4-19 = UUID
'        20,21 = major
'        22,23 = minor
'        24 = power
        //Check for iBeacon data
        rc = BleGetADByTag(dta$, 0xff, ADval2$)
        IF (rc == 0) THEN
            //Tag exists
            IF ((STRLEN(ADval2$) == 25 || STRLEN(ADval2$) == 24 || STRLEN(ADval2$) == 20) && StrGetChr(ADval2$, 2) == 0x02) THEN
                //Add device to table if not already in
                dim SkipDevice : SkipDevice = 0
                dim Lookup : Lookup = TableLookup(ScanTable$, ad$)
                IF (Lookup >= 0) THEN
                    IF (ScanDuplicates == 0) THEN
                        //Duplicate and set to not show duplicates
                        SkipDevice = 1
                    ENDIF
                ELSEIF (Lookup == -1 || Lookup == -2) THEN
                    //Not in, add
                    rc = TableAdd(ScanTable$, ad$, ScanDeviceCount)
                    AssertResCode(rc, 111)
                    ScanDeviceCount = ScanDeviceCount+1
                ENDIF

                IF (SkipDevice == 0) THEN
                    //Show device
                    dim ibUUID$, ibMajV, ibMinV, iBPower
                    PRINT "\n"
                    IF (DisplayMode >= 0 && DisplayMode < 7) THEN
                        //Output MAC address
                        PRINT "(";StrHexize$(ad$);") "
                    ENDIF
            
                    IF (DisplayMode == 0 || DisplayMode == 1 || DisplayMode > 4) THEN
                        //Output device name
                        PRINT "[";ADval1$;"] "
                    ENDIF
            
                    //Always output RSSI
                    PRINT "RSSI: ";rsi
            
                    IF (DisplayMode == 0 || DisplayMode == 7) THEN
                        //Output UUID
                        ADval1$ = MID$(ADval2$, 4, 16)
                        PRINT ", UUID: ";STRHEXIZE$(ADval1$)
                    ENDIF
            
                    IF ((STRLEN(ADval2$) == 25 || STRLEN(ADval2$) == 24) && (StrGetChr(ADval2$, 3) == 0x15 || StrGetChr(ADval2$, 3) == 0x14)) THEN
                        //Version information is also provided
                        dim TmpStr1$
                        TmpStr1$ = MID$(ADval2$, 20, 2)
                        IF (DisplayMode == 0 || DisplayMode == 1 || DisplayMode == 2 || DisplayMode == 7 || DisplayMode == 8) THEN
                            //Output version
                            dim TmpStr2$
                            TmpStr2$ = MID$(ADval2$, 22, 2)
                            PRINT ", version: ";STRHEXIZE$(TmpStr1$);".";STRHEXIZE$(TmpStr2$)
                        ENDIF
                
                        IF (STRLEN(ADval2$) == 25 && StrGetChr(ADval2$, 3) == 0x15) THEN
                            //Calibrated power information is included
                            IF ((DisplayMode >= 0 && DisplayMode < 4) || DisplayMode == 5 || (DisplayMode > 6 && DisplayMode < 10)) THEN
                                //Output power
                                TmpStr1$ = MID$(ADval2$, 24, 1)
                                dim TmpInt
                                rc = BleDecodeS8(TmpStr1$, TmpInt, 0)
                                PRINT ", calibrated power: ";TmpInt;"dBm"
                            ENDIF
                        ENDIF
                    ENDIF
                ENDIF
            
                IF (ScanDevices > 0 && ScanDeviceCount >= ScanDevices) THEN
                    //Finish scanning as number of devices found is enough
                    rc = BleScanStop()
                    AssertResCode(rc, 33)
                    PRINT "\nScanning stopped (device limit reached)"
                ENDIF
            ENDIF
        ENDIF
        rc = BleScanGetAdvReport(ad$,dta$,ndisc,rsi)
    endwhile
endfunc 1

//-------------------------------------------------------------------------
//#CMD#//  displaymode #INTmode#
//#CMD#//  timeout #INTtimeoutsec#
//#CMD#//  duplicates #INTshowduplicates#
//#CMD#//  devices #INTdevicestoshow#
//#CMD#//  txpower #INTtxpower#
//-------------------------------------------------------------------------
function _Config()
    tlen = ExtractStrToken(urtcmd$,tkn$)
    if tlen == 0 then
        exitfunc 5
    endif
    //=================================================
    if strcmp(tkn$,"displaymode")==0 then
        //extract 1 (#INTmode#) and store starting at i[1]
        rc = ExtractIntTokens(urtcmd$,1,1)
        if rc != 0 then
            exitfunc rc
        endif
        
        IF (i[1] >= 0 && i[1] < 11) THEN
            //Valid display mode
            DisplayMode = i[1]
            exitfunc 0
        ELSE
            //Invalid display mode
            exitfunc 6
        ENDIF
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    elseif strcmp(tkn$,"timeout")==0 then
        //extract 1 (#INTtimeoutsec#) and store starting at i[1]
        rc = ExtractIntTokens(urtcmd$,1,1)
        if rc != 0 then
            exitfunc rc
        endif
        ScanTimeout = i[1]
        exitfunc 0
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    elseif strcmp(tkn$,"devices")==0 then
        //extract 1 (#INTdevicestoshow#) and store starting at i[1]
        rc = ExtractIntTokens(urtcmd$,1,1)
        if rc != 0 then
          exitfunc rc
        endif
        ScanDevices = i[1]
        exitfunc 0
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    elseif strcmp(tkn$,"txpower")==0 then
        //extract 1 (#INTtxpower#) and store starting at i[1]
        rc = ExtractIntTokens(urtcmd$,1,1)
        exitfunc BLETXPOWERSET(i[1])
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    elseif strcmp(tkn$,"duplicates")==0 then
      //extract 1 (#INTshowduplicates#) and store starting at i[1]
      rc = ExtractIntTokens(urtcmd$,1,1)
      if rc != 0 then
        exitfunc rc
      endif
      
      if (i[1] == 0 || i[1] == 1) then
          //Valid
          ScanDuplicates = i[1]
          exitfunc 0
      else
          //Invalid
          exitfunc 6
      endif
    endif
endfunc 5

//-------------------------------------------------------------------------
//#CMD#//  scan
//#CMD#//  stop
//#CMD#//  config
//#CMD#//  exit
//#CMD#//  quit
//-------------------------------------------------------------------------
function OnUartCmd() as integer
  rc=-2 //default response is ">"
  tlen = ExtractStrToken(urtcmd$,tkn$) //get first token
  if tlen > 0 then

    if strcmp(tkn$,"stop")==0 then
        //Stop scanning for iBeacons
        rc = BleScanStop()

    elseif strcmp(tkn$,"scan")==0 then
        //Start scanning for iBeacons
        rc = TableInit(ScanTable$) //Create lookup table
        AssertResCode(rc, 333)
        ScanDeviceCount = 0
        rc = BleScanStart(ScanTimeout*1000, 0)
        
    elseif strcmp(tkn$,"config")==0 then
        //Change configuration
        rc = _Config()

//Reserved for future use:
//    elseif strcmp(tkn$,"connect")==0 then
//      rc = _Connect()

//Reserved for future use:
//    elseif strcmp(tkn$,"disconnect")==0 then
//      rc = _Disconnect()

    elseif strcmp(tkn$,"exit")==0 || strcmp(tkn$,"quit")==0  then
      exitfunc 0

    endif
  endif
  // send a response back to the user
  UartRsp(rc)
endfunc 1

//==============================================================================
// This handler is called when there is a scan attempt timeout
//==============================================================================
function HandlerBlrScanTimOut() as integer
  DbgMsg( "\nScanning stopped via timeout" )
endfunc 1

//==============================================================================
// This handler is called when there is an advert timeout
//==============================================================================
function HandlerBlrAdvTimOut() as integer
  DbgMsg( "\nAdverts timeout" )
endfunc 1

//==============================================================================
// This handler is called when data has arrived at the serial port
//==============================================================================
function HandlerUartRxCmd() as integer
  dim nMatch
  
  if urts < 0 then
    //uart parser is suspended
    exitfunc 1
  endif

  //check if CR has been received
  nMatch=UartReadMatch(stRsp$,13)
  if nMatch!=0 then
    //CR exists in the input buffer
    urtcmd$ = strsplitleft$(stRsp$,nMatch)
    exitfunc OnUartCmd()
  endif
endfunc 1

//Startup
print "\n\r";BleGetDeviceName$();"\n\r"
//Send an OK response
UartRsp(0)

OnEvent  EVUARTRX                 call HandlerUartRxCmd
OnEvent  EVBLE_ADV_TIMEOUT        call HandlerBlrAdvTimOut
OnEvent  EVBLE_SCAN_TIMEOUT       call HandlerBlrScanTimOut
OnEvent  EVBLE_ADV_REPORT         call HandlerAdvRpt

WAITEVENT
